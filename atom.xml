<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neil</title>
  
  <subtitle>忙碌且懂得感恩的人，运气不会太差 ◑０◐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://neilli.cn/"/>
  <updated>2020-09-27T13:55:45.825Z</updated>
  <id>https://neilli.cn/</id>
  
  <author>
    <name>stream.neil@gmail.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构 - 分布式消息队列（一）</title>
    <link href="https://neilli.cn/2020/09/07/architect-queue1/"/>
    <id>https://neilli.cn/2020/09/07/architect-queue1/</id>
    <published>2020-09-06T16:11:21.000Z</published>
    <updated>2020-09-27T13:55:45.825Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列的作用我们大家都知道，本文主要从整体上学习下消息队列的同步与异步、以及异步架构及其反模式、异步架构有哪些好处、挑战和问题等。</p><h2 id="统一日志服务设计"><a href="#统一日志服务设计" class="headerlink" title="统一日志服务设计"></a>统一日志服务设计</h2><p>我们中台搞到现在不得不上消息队列，目前场景是用到统一日志中心处。</p><p><img src="queue1-1.png" alt=""></p><p>统一日志中心作为中台的基础服务，承担着所有业务服务的系统日志、业务日志的收集和输出、检索功能。便于开发者利用此服务迅速定位自己服务的问题，而不用一有问题就去找运维、或进生产环境查看日志，况且目前环境是 docker + k8s 更不利于普通开发者去查看和定位。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步模式，是请求调用发起之后，会一直阻塞直到调用方把请求处理完成。</p><p><img src="queue1-2.png" alt=""></p><p>服务A发起了发送短信的调用之后，就一直阻塞，等待调用方相应。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步就是调用方发起请求之后，直接得到请求发送成功之后，剩下的就不管了。然后调用方就可以去干其他事情。好像 多线程 类似。</p><p><img src="queue1-3.png" alt=""></p><h2 id="消息队列异步架构"><a href="#消息队列异步架构" class="headerlink" title="消息队列异步架构"></a>消息队列异步架构</h2><p>生产者生产消息加入到消息队列，消费者生产消息，基于消息体去做相应的业务操作。这本身相对于生产来说就是异步的。生产者生产了消息之后就直接可以不用等待处理结果，就可以去做其他事情，本身就是异步。</p><p>所以，会有3个角色：生产者、消费者、消息队列</p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者，顾名思义就是生产消息的。它的职责很简单，就是构建1个合法的消息，然后把消息加入到队列中。应用开发者来觉定何时何地构建消息。</p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者，就是消费消息的，并根据消息体来做不同的业务。它与生产者隔离，可以在不同的服务器，也相互不依赖，并能通过服务器扩容来实现消费速度的增加。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列就是生产者生产消息存放的地方，也是消费者取消息的地方，通常其性能很高，所以能给消费者充当缓存作用。其实现可以有很多，比如：共享文件、数据库和NoSQL，以及分布式消息队列服务器。</p><p>常用的消息队列产品有：Kafka、RabbitMQ、ActiveMQ、RecketMQ。</p><h2 id="消息队列模式"><a href="#消息队列模式" class="headerlink" title="消息队列模式"></a>消息队列模式</h2><h3 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h3><p>生产者构建消息添加到消息队列中，消息队列中的另一端是多个消费者，当消息达到队列中时，消费者通过竞争获取消费某个消息的权利，那次消息就会被路由到此消息队列消费（且只会路由到1个消费者）。所以，点对点模式的消息只会被1个消费者消费，而消费者消费的消息也只是消息队列中一部分（取决于消费者数量）。</p><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>与点对点模式相反，该模式下的消息是可以被多个消费者消费。生产者构建的消息发送到某个主题(topic)下（而不是队列），当消息到达某个主题下后就会被克隆给每个订阅此主题的消费者，每个消费者接受一份消息复制到自己私有队列。</p><p>两种模式各有各的使用场景。比如上面 UML 图中，在点对点模式下，生产消息扔进队列之后，生产者就可以不用管它了，而消费者也不用管是谁生产的，接受到之后就直接调用短信服务发送即可。一个短信消息只能被发送1个次，所以这个场景下适合使用点对点。</p><p>发布订阅模式，比如，当新用户注册成功这个场景，加入生产者是用户服务，在注册成功构建一个用户注册的消息，发布到用户注册的topic下，现在新增1个消费者：发送邮件激活消费者订阅、同步用户到另外1个服务消费者等。加入此时就2组消费者订阅了这个topic，那他们分别会接受到此消息，然后该发邮件的发邮件、该同步用户的同步用户，各司其职。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>异步</li><li>削峰</li><li>易扩容</li><li>解耦</li></ol><p>异步和削峰这个大家很熟悉，易扩容什么鬼？前面无论是点对点还是发布订阅模式，当消息队列中的消息过多，我们都可以很方便的增加物理机器来部署消费者，来达到10倍或几十倍的消息消费能力，从而提高消息的消费速度。因为生产者和消费者是独立的，相互不影响。这也是消息队列为何能解耦的原因。</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>前面说了那么多消息队列的好处，什么解耦、削峰啥的，这玩意那么好，是不是每个系统都应有去用的呢。其实不然，任何事物都有2面性，有好的一面，比如是有一面是代价。</p><p>分布式的复杂度是传统单体系统不能比的，还是消息队列的消息是无序的，所以消费者消费的时候不能指定谁先谁后，消息重入、丢失等。</p><p>消息无序其实是指入消息队列时能指定顺序，但是消费的时候是不能明确指定顺序。</p><p>消息重入会造成重复消费的风险，比如消息有个失败机制，当消费失败消息会被重新加入队列，但此时其实是消费成功了，一旦加入队列中，那消费者就会消费他，如果此消息不是幂等的，就会造成重复消费问题，比如发送短信，会被发送多次，或发放积分等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>消息队列在微服务架构中是必不可少的，那么个相互独立服务，服务之间解耦是肯定要用到的。其本身的异步架构能给我们在微服务架构上带来很多好处。</p>]]></content>
    
    <summary type="html">
    
      高并发架构设计中，肯定必不可少的要有消息队列吧。而对于整个公司做为 PaaS 层的能力组件，分布式消息队列肯定是不二选择了吧。故，总结下目前我们中台架构的分布式消息队列的设计。
    
    </summary>
    
    
      <category term="架构" scheme="https://neilli.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://neilli.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="消息队列" scheme="https://neilli.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>架构 - 分布式缓存（三）</title>
    <link href="https://neilli.cn/2020/09/03/architect-cache3/"/>
    <id>https://neilli.cn/2020/09/03/architect-cache3/</id>
    <published>2020-09-03T12:19:31.000Z</published>
    <updated>2020-09-16T09:36:42.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>顾名思义，分布式缓存和普通的缓存的区别就是在于，分布式缓存是通过多台缓存服务器以集群的形式对外提供缓存服务。</p><p>所以，分布式缓存的问题就在于我们有多台缓存服务器，当我们存了某个缓存在其中一台服务器，那当我们想获取的时候如何准确快速的找到这台服务器呢？</p><h2 id="余数算法"><a href="#余数算法" class="headerlink" title="余数算法"></a>余数算法</h2><p>假如缓存服务器搞3台，我们还是一样的存储 key, value，我们需要先把 key hashcode 之后，然后对 3 取模，定位出存储在哪台服务器。这样的足够简单，但是，不利于后期扩容。试想下，如果每台服务器已经存储了 100w 个 key，需要在扩容一台， 此时当需要获取缓存的 value 时，需要把 key 的 hashcode 对 4 取模去定位服务器，这无疑是灾难的。因为这样就找不到之前存储的服务器了。</p><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p>为了解决上面问题，我们采用一致性哈希算法。一致性哈希算法其实就是先构建一个哈希环，然后把服务器hashcode之后放到环上，存取的时候也是先把key hashcode之后放到环上。然后沿着顺时针找到key离得最近的那个服务器就是其所存储的服务器。</p><p>所以，这个算法有个天然的弊端，因为hash是随机的，所以，落到环上也是随机的，就有可能造成有的服务器存的多，有的少，造成不均。而后面扩容也是如此，如果扩容的服务器落到的那个存储量大的服务器那边，也可能会造成类似余数哈希一样的雪崩。</p><p>面对上面问题，业内比较通用的方式是使用虚拟节点。这个自己去学习吧。不讲了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本系列讲了缓存是我们常用的，且更容易提高性能的一个手段。要了解其分类；通读缓存和旁路缓存；哪些场景下适合用缓存、哪些场景下不适合用；以及其场景问题；最后，我们了解下分布式系统中常用的分布式缓存，并了解了2个常用的缓存路由算法，建议使用一致性哈希算法。</p>]]></content>
    
    <summary type="html">
    
      什么是分部署缓存？和我们之前用的单机或哨兵模式有啥区别？主要针对哪些应用场景呢？。
    
    </summary>
    
    
      <category term="架构" scheme="https://neilli.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://neilli.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="缓存" scheme="https://neilli.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>架构 - 分布式缓存（二）</title>
    <link href="https://neilli.cn/2020/08/30/architect-cache2/"/>
    <id>https://neilli.cn/2020/08/30/architect-cache2/</id>
    <published>2020-08-30T09:19:31.000Z</published>
    <updated>2020-09-15T00:43:08.388Z</updated>
    
    <content type="html"><![CDATA[<p>上节讲了对象缓存的基本概念和知识。当然，业务数据的缓存在整个系统架构中的重要性毋庸置疑，但是像方向代理、CDN 等，在高并发架构中的作用也不可小视，也是必不可少的。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>讲反向代理之前，小朋友肯定会说<code>正向代理</code>咋不讲呢？ 代理缓存其实就是客户端缓存，一般我们在架构中控制不了。</p><p><img src="daili.png" alt=""></p><p>如上图，我们访问 Http 时，如果有代理服务器，当前我们之前以及访问过该网页，则从代理服务器之前返回缓存的数据，如果没有，再去请求网络返回数据。更多时候，客户端都不一定知道他被加了代理服务器。</p><p>因为它是客户端缓存，不在缓存架构范围内，不做重点讨论。知道即可。</p><p>反向代理，顾名思义和和之前代理缓存反向的。代理缓存是代理客户上网的，而反向代理则是代理数据中心输出的。反向代理缓存是存储在数据中心的，是数据中心的统一入口。</p><p>刚刚说到反向代理缓存是存储在数据中心的，一般当外部流量访问数据中心时，通常是经过负载均衡到某个反向代理服务器，反向代理服务器在本地查找缓存，如果有则直接返回，不会到后面的应用服务器查询。反向代理缓存还可以以多层形式存在。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN 比较特殊，它不像反向代理缓存一样为网络服务商的缓存服务。如阿里云 CDN 缓存服务。</p><p>用户通过网络访问数据时，是通过网络服务商提供的网络链接才能链接到我们数据中心，那此时网络服务商就可以在自己提供的网络服务的机房里提供一次缓存服务。</p><p>比如，用户访问 <code>xingyun.com</code> ，由于第一次访问改服务，则会连接到数据中心返回数据给用户。下次再访问时 CDN 的反向代理缓存去命中一些静态资源，如果未命中则直接去数据中心获取。数据中心返回的数据依然要经过 CDN 服务器，此时它就可以把这些数据缓存起来，供下次访问使用。</p><hr><p>以上，就把代理缓存、反向代理、CDN等大致复习了下。其实还有一种缓存是客户端缓存，叫<code>旁路缓存</code>，那上面的那些就叫<code>通读缓存</code>。按字面意思应该能理解。</p><p>与通读缓存不同，是客户端自己先去旁路缓存查找数据，如果没有，则需要自己去数据中心获取数据，然后再缓存到旁路缓存。</p><h2 id="缓存场景问题"><a href="#缓存场景问题" class="headerlink" title="缓存场景问题"></a>缓存场景问题</h2><ol><li>避免频繁更新的内容用缓存；</li><li>没热点的缓存；</li><li>注意数据不一致性；</li><li>注意雪崩；</li></ol><p>上面学习了那么多，分布式缓存还是没讲到，下个章节我们开始我们的正题。</p>]]></content>
    
    <summary type="html">
    
      本来以为一篇能把缓存讲完，看来要单独讲下外部系统缓存了，也是架构的一部分，特别是高并发情况下。
    
    </summary>
    
    
      <category term="架构" scheme="https://neilli.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://neilli.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="缓存" scheme="https://neilli.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>架构 - 分布式缓存（一）</title>
    <link href="https://neilli.cn/2020/08/29/architect-cache/"/>
    <id>https://neilli.cn/2020/08/29/architect-cache/</id>
    <published>2020-08-29T15:19:31.000Z</published>
    <updated>2020-09-09T06:29:25.660Z</updated>
    
    <content type="html"><![CDATA[<p>缓存，相信每个做过后端的都应该很清楚，它有相对来说技术简单、对性能提升明显的特点广受后端研发和架构师的喜爱。</p><p>但是，不是所有的场景下都适合用缓存，所以，使用缓存的时候要注意以下几点：</p><ol><li>数据频繁修改，不适合用缓存。</li><li>数据无热点性，也就说用的情况不多，命中率低。</li><li>强一致性，不适合用缓存。</li><li>缓存可能会雪崩，从而导致整个系统瘫痪。</li></ol><h2 id="缓存特点"><a href="#缓存特点" class="headerlink" title="缓存特点"></a>缓存特点</h2><ol><li>技术简单</li><li>性能提升明显</li><li>应用广泛</li></ol><p>从计算机、数据库到浏览器我们能看到很多缓存的身影。在外部系统中有：DNS 缓存、浏览器缓存、Http 代理和反向代理、CDN 缓存以及各种对象缓存。所以，本章我们重点要学习的就是对象缓存，常见的有：Redis，Memcached 等。</p><h2 id="缓存为什么那么显著的提升性能呢"><a href="#缓存为什么那么显著的提升性能呢" class="headerlink" title="缓存为什么那么显著的提升性能呢"></a>缓存为什么那么显著的提升性能呢</h2><ol><li>缓存的数据来自于内存，计算机访问内存数据肯定是比磁盘更快的。</li><li>缓存中数据是最终业务需要的数据，不像存储到数据库中的，我们业务需要的时候还要捞出来处理一遍。</li><li>从缓存获取数据，降低了磁盘和网络负载和延迟。</li></ol><h2 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h2><p>缓存的数据结构主要是 Hash 表，这个和 HashMap 和 HashTable 一样，都是基于 Hash 表实现的。</p><p>什么是 Hash 表？</p><p>它其实是一个数组结构，也就说它需要的存储空间是必须连续的。这样就会有个风险，如果你的连续内存不够多，而你存储一个比较大的数据，此时可能会内存溢出。比如：即使你的内存还剩下 512M ，你存储 1 个 400M 的数据，你认为够了，但还是报 OOM 了，原因就在于此。</p><h2 id="往缓存加数据"><a href="#往缓存加数据" class="headerlink" title="往缓存加数据"></a>往缓存加数据</h2><p>比如，需要加一个 ”name”: “neil” 的数据，具体流程如下：</p><p><img src="setcache.png" alt=""></p><h2 id="从缓存获取数据"><a href="#从缓存获取数据" class="headerlink" title="从缓存获取数据"></a>从缓存获取数据</h2><p>如果要从缓存中获取数据，比如 cache.getValue(‘name’)，其流程和上面类型。</p><ol><li>先获取 key 的 hashcode。</li><li>hashcode 对数组长度取模。</li><li>然去对应数组 index 去找 value。</li></ol><h2 id="缓存键集合大小"><a href="#缓存键集合大小" class="headerlink" title="缓存键集合大小"></a>缓存键集合大小</h2><p>刚刚我们用具体例子熟悉了写入缓存和获取缓存的流程和机制。我们知道，缓存是通过键来精准匹配数据的。</p><p>再比如，如果我们要缓存整个会员(用户)的数据，那我们的键就是 UserID ,那键集合空间就是我们这个系统所有的会员的全体 ID ，比如我们有 1000w 个会员，那我们就会有 1000w 个键存在缓存键集合中。</p><p>在设计缓存中有个必须注意的点：键越少越好。重点体现在它性能方面。</p><h2 id="缓存内存空间大小"><a href="#缓存内存空间大小" class="headerlink" title="缓存内存空间大小"></a>缓存内存空间大小</h2><p>缓存的数据是存储在内存中，内存空间越大，其缓存对象就会越多。一般我们缓存的大小都不会像硬盘一样搞个几百 G，或几个 T，所以，缓存的使用要有规范，不能什么数据都塞进来。在特定大小的缓存里，如果要缓存新对象，肯定要删除一些老的对象，删除老的对象肯定会影响缓存命中。</p><p>物理缓存空间越大，缓存对象越多，缓存命中越高。</p><h2 id="缓存命中率"><a href="#缓存命中率" class="headerlink" title="缓存命中率"></a>缓存命中率</h2><p>缓存命中率也是经常面试中经常被问到的。我们知道我们使用缓存的场景是读多写少，我们希望通过缓存来实现一次数据库查询写入缓存之后，满足后面多次查询的请求，减少数据库压力，直接从缓存获取数据，提高性能。所以，希望缓存命中率越高越好。</p><p>计算公式：正确缓存查询得到数据次数 / 查询总次数。</p><p>当然，缓存生产时间、上面的说的键集合大小、内存空间都是影响命中率的因素。</p><h2 id="缓存寿命"><a href="#缓存寿命" class="headerlink" title="缓存寿命"></a>缓存寿命</h2><p>缓存的对象的生存时间称为 TTL。刚刚说了缓存的时间、缓存空间越大缓存命中就会越高，但是内存不是足够大，总要有所取舍。</p><p>缓存失效的方式有：实时失效、过期失效、LRU失效。</p><h3 id="实时失效"><a href="#实时失效" class="headerlink" title="实时失效"></a>实时失效</h3><p>当我们缓存了某个数据，比如某个商品信息，此时我们更像商品的价格，此时需要直接删除缓存的数据。当获取这个商品的时候先从缓存获取，返回为空，然后此时从数据库查询获取最新数据，再更新缓存。</p><p>注意，更新数据，直接删除缓存，不可直接更新缓存。</p><h3 id="过期失效"><a href="#过期失效" class="headerlink" title="过期失效"></a>过期失效</h3><p>我们存储数据的时候会设置对象的过期时间，如果到时间之后，对象会自动被删除（其实是缓存有算法轮询删除）。</p><p>注意，此时注意那些过期时间为 <code>-1</code> 的对象。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU 是最近最久未使用算法。当缓存空间不够，如果要存入新的对象，是需要删除一些对象才可以存储进来新的。此时可以使用 LRU 算法。这个算法，也经常会被面试问到。</p><p>大致实现：一个链表来实现，当访问了某个对象，把对象移到队头。所以，越往队尾就代表越少被访问，删除是则从队尾开始删除。</p><p>今天先从基本概念了解下缓存。下节我们复习下外部系统的缓存，如反向代理之类的。</p>]]></content>
    
    <summary type="html">
    
      缓存，是我们后端用到最多、最频繁、也是相对不那么陌生的一个组件了，在中台架构中缓存是充当什么角色呢？今天晚上整好梳理下。
    
    </summary>
    
    
      <category term="架构" scheme="https://neilli.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://neilli.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="缓存" scheme="https://neilli.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>管理思考 - 我平常在干些啥</title>
    <link href="https://neilli.cn/2020/08/27/what-doing-as-m/"/>
    <id>https://neilli.cn/2020/08/27/what-doing-as-m/</id>
    <published>2020-08-27T10:19:31.000Z</published>
    <updated>2020-09-08T03:52:48.724Z</updated>
    
    <content type="html"><![CDATA[<p>回到主题：做管理，平常都是干啥。其实，如果这个问题放到几年前，或许我真不知道该如何回答。</p><p>为什么呢？</p><p>或许你会想做团队管理不就是定下目标、分分任务、协调下事情、攻克难题吗？说，还能有啥~ 的确是如此，但又不是如此。</p><p>刚来公司是2012年，讲真，没想到会待公司那么多年。自己从技术做到管理；从客户端做到前端、后端；从 Java 做到了 Python、PHP、Vue；从 Android主管做到 App主管，又到部门负责人，再到公司云计算研发总监，负责研发、产品、UI、测试整体负责人，再到目前中台部架构整体负责人，经历很多，做的事情，接触到的人都很多。有年轻气盛为了一个功能的技术实现和甲、乙、丙、丁方争执一下午，也有为了一个产品流程或细节<code>指定江山不可一世</code>… 之前认为做管理不是通过学习，就是通过上面一个个活生生的例子总结的经验，所属管理就是<code>经验</code>。</p><p>刚做管理的新人，他每天做的事情基本就是上面的那些，再加上学着自己领导做些管理。</p><p>之前我对管理也是无意识，直到2015年，我的领导扔给我一本书《卓有成效的管理者》。当时，无感。2个月都没看完，实在看不下去。但是，本是好书，只是自己阅历不够，当时看不懂。后面自己慢慢的翻阅，加上自己的经历，明白了德鲁克老爷子的良苦用心：计划、组织、指挥、协调和控制。做到这5个基本要素，你得到了管理的精髓。哈哈哈。好了，这本书你可以不用看了。</p><p>或许小伙伴你会想，咦，这是不是管理的教科书呢？因为大家做技术出身，都是希望能像学技术一样获得一本《Java 葵花宝典》、《Python 入门到精通》等等类似这样的具有指导意义的<code>教科书</code>，但是很遗憾，管理上没有这样的<code>秘籍</code>。</p><p>好，那又回到正题，做管理究竟在干啥，除了上面：<code>定下目标、分分任务、协调下事情、攻克难题</code>没了吗？其实这是刚做管理的小伙伴首先想到，也是积极做的。但是，做管理远不止如此。管理的初衷是希望通过团队来协助你完成团队目标，由此可见团队至关重要。</p><p>那怎么搞团队建设呢？团队建设又称<code>团建</code>。有同学可能会说<code>团建</code>我知道，就是每月出去吃一顿。哈哈，好吧。其实很多时间我们都是这么做的。这只是团建建设的一个手段。真正的<code>团队建设</code>一定围绕着自己的<code>团队文化</code>、<code>能力梯队</code>、<code>协作沟通</code>、<code>职责分工</code>、<code>绩效激励</code>来展开，而我们比较喜欢的吃吃喝喝就是<code>协作沟通</code>的一个手段。</p><p><code>团队文化</code>如何搞呢？网上之前火了一个马云 diss <code>腾百万</code> 的一个段子：<code>如果一个企业或组织没有文化、愿景和使命，任何结合都是乌合之众</code>。所以，一个团队也是如此。或许你会说我tmd的做了几年的部门经理了，从来没想过还文化呢，不也好好的过了好几年吗？先不说这样的不好，我们可以设想如果你在这样的一个团队有什么好处：</p><ol><li>有归属感；</li><li>做事有方向、有成就感；</li></ol><p>那应该如何做呢？首先你作为此团队负责人，第一要明确公司成立此团队的目的是什么？是为了解决什么问题的？实现什么价值的？然后你基于此上升到部门的使命和愿景，从而形成部门文化。一旦明确文化方向，你坚持做下去，文化是个长久的，可能需要几个月的时间大家才有感觉。一旦发现团队有不适合此文化的，立刻开除。前提是和领导确认你的文化是否正确、以及他是否真的不适合此文化。</p><p><code>绩效激励</code>就不说了吧。绩效是只能给团队表现优异的人，要少~ 如何谈绩效之前有聊过<a href="https://www.neilli.cn/2020/08/24/how-to-jixiao/" target="_blank" rel="noopener">如何谈绩效</a>。</p><p><code>能力梯队</code>，如果一个团队要想持续发展，你这个老大想当的<code>省力</code>，你的团队有能力梯队，如果大家能力都很一样，你要重点培养，加以激励或从外面招聘也要有梯队。重要性，自己看吧。</p><p>总结下，自己有感而发，我平常干的啥啊：</p><ol><li>规划<ol><li>部门职能规划</li><li>部门目标、月度目标规划</li><li>团队规划，就是你要一个什么样的团队</li></ol></li><li>团建<ol><li>团队文化</li><li>能力梯队</li><li>协作沟通</li><li>职责分工</li><li>绩效激励</li></ol></li><li>任务<ol><li>重要紧急&gt;紧急不重要&gt;重要不紧急&gt;不紧急不重要，哈哈这不是废话吗？</li><li>执行，领导的任务，明确好了重在执行</li></ol></li></ol><p>除了上面一点还有一个最重要是：<code>流程制度和规范</code>。从部门到公司，部门的好理解，如果你有机会从公司层面制定规范和制定，那请你珍惜加油吧。</p><p>好了，今天扯那么多，下班~</p>]]></content>
    
    <summary type="html">
    
      前一段时间很忙，没有静下来去思考。人啊，一旦忙碌起来，他的思考能力就会受限制。这样很不好，如果你感觉很忙。这段时间你要注意了，特别是你在带一个团队的时候。
    
    </summary>
    
    
      <category term="管理" scheme="https://neilli.cn/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="管理" scheme="https://neilli.cn/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="思考" scheme="https://neilli.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>团队管理-如何去和小伙伴谈绩效2</title>
    <link href="https://neilli.cn/2020/08/24/how-to-jixiao2/"/>
    <id>https://neilli.cn/2020/08/24/how-to-jixiao2/</id>
    <published>2020-08-24T08:00:40.000Z</published>
    <updated>2020-09-07T09:44:55.773Z</updated>
    
    <content type="html"><![CDATA[<p>承接上文：<a href="https://www.neilli.cn/2020/08/22/how-to-jixiao/" target="_blank" rel="noopener">团队管理-如何去和小伙伴谈绩效</a>，直奔主题：</p><h3 id="1-明确绩效目标"><a href="#1-明确绩效目标" class="headerlink" title="1. 明确绩效目标"></a>1. 明确绩效目标</h3><p>作为团队管理者，你要为团队每月目标负责。所以，自己心中要有明确的目标，且可衡量的目标。所以，你梳理的每个目标都有具体目标绩效的直接影响人，无论按计划是第一周做还是第四周做，都是本月的目标。</p><p>如果绩效目标没有到位。前期目标没有确认、没有共识，单纯靠后期的绩效沟通是达不到效果的。</p><p><strong>目标是可以变化的。</strong> 面对可能变化的目标，尽量和小伙伴按周目标明确，然后基于周去打绩效。这就是绩效目标。</p><p>总结就是：</p><ol><li>定好月度计划；</li><li>和小伙伴明确他的本月大的目标，这是他本月绩效的评估依据；</li><li>每周和小伙伴确认本周目标；</li><li>明确计划可能有变动；</li><li>基于周打周绩效；</li><li>月底绩效面谈；</li></ol><h3 id="2-战胜心魔，摆正身份去沟通"><a href="#2-战胜心魔，摆正身份去沟通" class="headerlink" title="2. 战胜心魔，摆正身份去沟通"></a>2. 战胜心魔，摆正身份去沟通</h3><p>在<a href="https://www.neilli.cn/2020/08/22/how-to-jixiao/" target="_blank" rel="noopener">团队管理-如何去和小伙伴谈绩效</a>中说了，绩效面谈之所以感觉不好谈是因为自己心里作用。如果按前面把绩效目标明确好了，沟通时有理有据，客观沟通，并在沟通中相互探讨达成共识（管理者也可能有错的，可以在沟通中改变对其的绩效评价）。再者，你是作为团队的管理者去沟通，是团队负责人，你是有责任和义务去评价团队成员的工作表现和完成业绩的。你是站在整个团队的角度是对待绩效这个事情，而不是站在他的对立面，故意给他低绩效的。作为管理者，大家相对来说对你有一定的信任，你给某个小伙伴低绩效一定要有一定的让人信服的评估标准，要有一个管理者的职业操守，不能和谁关系好就怎样怎样。</p><h3 id="3-着眼未来"><a href="#3-着眼未来" class="headerlink" title="3. 着眼未来"></a>3. 着眼未来</h3><p>在沟通中，自己要怀着<code>着眼未来</code>的心态去沟通、去引导小伙伴。通过自己的沟通要把这个<code>坏消息</code>转变成对其的鼓舞和信任，让其对下个月的绩效充满希望和干劲，不能沟通完，让他感觉：完了，高绩效始终不会属于我了。</p>]]></content>
    
    <summary type="html">
    
      上一篇分析了如何谈绩效的`心理学`，具体如何实施，我分享下我如何做的吧。仅供借鉴，因为没有一个方法是通用且亘古不变的。
    
    </summary>
    
    
      <category term="管理" scheme="https://neilli.cn/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="管理" scheme="https://neilli.cn/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="绩效" scheme="https://neilli.cn/tags/%E7%BB%A9%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>团队管理-如何去和小伙伴谈绩效</title>
    <link href="https://neilli.cn/2020/08/22/how-to-jixiao/"/>
    <id>https://neilli.cn/2020/08/22/how-to-jixiao/</id>
    <published>2020-08-21T16:42:40.000Z</published>
    <updated>2020-08-28T10:50:32.279Z</updated>
    
    <content type="html"><![CDATA[<p>作为领导，与小伙伴面谈的场景中，你要问什么是最难的面谈，那非绩效面谈莫属了。为什么呢？难在哪里呢？好像说不上来，是吧？</p><p>如果绩效大家都是7+，哈哈，肯定好谈，你所认为的绩效不好谈是因为对那些低绩效的小伙伴不知道如何去谈。其实这都是你自己心里作用在捣鬼，因为你在面谈之前就已经把低绩效这件事当成一个坏消息去谈了。曾几何时，我也是如此。因为没有哪个人喜欢听别人给自己说关于自己的坏消息。因为大家都喜欢被表扬吗。所以，从开始如果你把低绩效当成了坏消息去谈，那恭喜你，你中奖了。别认为你自己会觉得尴尬，别人也会啊，所以到头来，就是一场尬聊。</p><p>这是心理作用之一，还有一个心理作用。你仔细想想，他的这个绩效是谁给的。当然是你啊。那么你心里又会有个负担，是我给他的低绩效。所以，我对此有歉意。整个聊天过程中，你有意无意的会透漏出歉意。特别是在小团队中，人数不多的情况下， 一般管理者都会认为，表现好的自然7+，剩下的大家都差不多，结果每月绩效必须搞个<code>爱因斯坦相对论的7-</code>，如果对这个过程很痛苦，那估计说明你的歉意更加重了。而此时你找他谈绩效的时候，你会有点忧虑和同理心。综上心理作用，每到月底绩效面谈都会很不得劲对吧。</p><p>好了，明白了上面的那就好办了。我不把它当成坏消息去谈，去当成好消息去谈：哈哈，小明，恭喜你哈，本月你7-… 小明：一脸懵逼… 那真正该咋做呢？</p><p>要理解如何去做，首先要明确绩效沟通的价值和真正意义。也就是说你作为管理者是想通过这10min的绩效沟通想到达一个什么结果呢？或要收货什么呢？咦，这么说，我就突然明白了：绩效沟通当然是想让这部分低绩效的小朋友，在面对自己本月低绩效面谈时没有负能量、没反作用力，还要认同本月的绩效，并能激励他下个月积极提高，争取7+。那就ok了。</p><ol><li><p>目标对齐，你要把小伙伴的目标引导到和你目标一致。沟通是对等的，面对这个本月既定的绩效，小伙伴对此的判断是和看法是什么，做到相互了解，客观平静的给出你对此的评价标准，同样小伙伴也要表达出对此评价的标准。总之，就是基于事实信息、逻辑判断（程序员思维）、目标对齐（沟通意图）、评价标准去达成共识。如果共识未达到，那就歇菜了，会明显表现在：哎，都是领导说了算，即使在努力，领导认为谁7+谁就7+，认为谁7-谁就7-。往往小伙伴不会去想作为领导者其实相对和客观的，没必要偏袒任何一个人。</p></li><li><p>明确辅导，绩效的还有一个目的，是小伙伴要去回顾本月的为何我7-了。让小伙伴去更多的思考和观察，思考是思考自己、观察是观察别人。而领导者要做的是在这个过程中最好能绩效教练式的辅导，而不是说教。不然会适得其反。不在7-的小伙伴身上以身作则，要你何用~</p></li><li><p>给予激励，绩效沟通的最最重要的一点是：通过这次沟通能让小伙伴理解并认可本月绩效，然后重燃斗志。</p></li></ol><p>还是说了一堆废话。还是没用明确如何去谈。</p><p>讲真，我也不知道，哈哈哈。~~ 但是我相信你能想到这么多，应该会体会出适合自己的方式和方法吧。加油</p><p>不说了，码代码吧。</p>]]></content>
    
    <summary type="html">
    
      眼看下周又到月底了，每月的绩效面谈，又来了。从开始的不适应，到后来的摆正心态，明确如何去谈，想总结下。正好这很长一段时间都没更新CoreJava了。
    
    </summary>
    
    
      <category term="管理" scheme="https://neilli.cn/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="管理" scheme="https://neilli.cn/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="绩效" scheme="https://neilli.cn/tags/%E7%BB%A9%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(10） - 谈谈 Java JVM（二）</title>
    <link href="https://neilli.cn/2020/06/01/corejava-10-jvm2/"/>
    <id>https://neilli.cn/2020/06/01/corejava-10-jvm2/</id>
    <published>2020-05-31T16:32:40.000Z</published>
    <updated>2020-07-21T12:05:05.313Z</updated>
    
    <content type="html"><![CDATA[<p>如何观察 JVM 堆内存的使用情况，成了我们日常排查问题很重要的手段。大致如下：</p><ul><li>JConsole（堆内存、堆外内存）、VisualM 它们是直接连接 Java 进程，然后在图形化界面掌握内存情况。</li><li>jstat、jmap命令行工具进行查询 - 堆、方法区；</li><li>GC 日志；</li><li>NMT（堆外内存的直接内存）；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NativeMemoryTracking=summary</span><br></pre></td></tr></table></figure><p>默认是关闭。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>内存对象分配在JVM中堆以外的内存，也可以称为直接内存，这些内存直接受操作系统管理（而不是JVM），这样做的好处是能够在一定程度上减少垃圾回收对应用程序造成的影响。一般我们使用Unsafe和NIO包下ByteBuffer来创建堆外内存。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>减少 GC</li><li>提高 IO 效率</li></ul><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>从年代角度划分：新生代、老年代、永久代；</p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>绝大多数的对象的创建和销毁的区域，在通常Java应用中，绝大多数对象的生命周期都是很短暂的。</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>放置长生命周期的对象，通常都是从Survivor区域拷贝过来的对象。有特殊情况，如果对象过大，会分配到新生代eden其他位置；如果过大，无法在新生代找到足够长的连续空间，JVM 会直接分配到老年代。</p><h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>存储 Java 元数据、常量池、Inter字符串缓存。jdk8就没有永久代了。</p><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>Thread Local Allocation Buffer, JVM 为每个线程分配一个私有内存区域，因为多个线程同时操作时，为了避免操作同一地址，可能使用加锁机制，进而影响分配速度。</p>]]></content>
    
    <summary type="html">
    
      这段时间中台的 Java 服务正式运行了，但是遇到些问题，不时有的服务会停止；或者有的 PHP 服务的心跳不正常，所以，从 Java 服务角度，是要看下其内存的使用情况，也是排查问题手段之一吧。所以，趁机梳理和归纳了监控和诊断 JVM 内存的工具和方法，以供部门人员日后学习。
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://neilli.cn/tags/JVM/"/>
    
      <category term="内存诊断" scheme="https://neilli.cn/tags/%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(9) - 谈谈 Java JVM（一）</title>
    <link href="https://neilli.cn/2020/05/14/corejava-9-jvm1/"/>
    <id>https://neilli.cn/2020/05/14/corejava-9-jvm1/</id>
    <published>2020-05-14T06:52:40.000Z</published>
    <updated>2020-06-03T09:25:49.935Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道 Java 里面有垃圾回收，有了它，我们在码 Java 代码的时候确实省了不少事情。但是，如果我们仅仅停留在让垃圾回收来给我们管理我们的内存的话，那我们的只能写出一般般的程序。所以，如果想要能设计高扩展性以及对性能和内存调优有更好要求的小伙伴来说，熟悉 JVM 及其内存结果和工作机制，是必不可少的。</p><h1 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>又称PC寄存器（Program Counter Register）。在 JVM 中每个线程都有一个程序计数器。那为什么每个线上都要有这么一个计数器呢？弄清这个问题，首先我们要先想下在 JVM 多线程内部机制是怎样的？ 多线程，它不是这些线程同时在执行，而是同时只有1个线程在执行，通过线程轮流切换来获得 CPU 的执行时间。线程在执行的时候（也就是 CPU 执行指令时），它就是从当前线程的 PCG(Program Counter Register) 中来获取当前需要执行 JVM 指令的地址的。</p><p>总结一句话：程序计数器就是用来存储当前线程正在执行的 Java 方法的 JVM 指令地址。这样我们可以得出，如果当前线程执行的是本地方法，那程序计数器的值就是undefind。</p><p>再想一个问题，在多线程，如果线程 A 执行方法 a(), 当前线程切换到 B 执行完方法 b(), 此时线程再切换到 A 去执行 a(), 其结果，我们都知道是之前是一样的，这是为什么呢？</p><p>这就是程序计数器的功劳。因为每个线程都有一个独立的程序计数器，当线程执行完，CPU 发出线程切换后，上一个线程的程序计数器会回复到其执行之前的状态。当下次再轮到它执行时，它还能保持和第一次执行的状态一样。神不神奇？ 还有神奇的是：程序计数器永远不会 OOM。因为其存储的数据大小是固定的，不会因为方法和线程的执行而发生变化的。这个也能想明白。所以，当面试官问你：程序计数器在何时会 OOM 时。你要当心掉坑里啊。</p><h2 id="Java-虚拟栈"><a href="#Java-虚拟栈" class="headerlink" title="Java 虚拟栈"></a>Java 虚拟栈</h2><p>Java Virtual Machine Stack，线程在创建的时候都会创建一个 Java 虚拟栈，方法在执行前会先创建一个栈帧。栈帧是什么呢？ 它是一个数据集结构，里面有局部变量表、操作数栈、动态链接、方法正常出口和异常出口。</p><p>在前面我们讲了 CPU 在执行的时候只能一个线程一个线程的执行，在执行的线程成为‘当前线程’；同理，那在执行的方法也称为‘当前方法’；方法在执行之前会先创建一个栈帧，那此栈帧就称为‘当前栈帧’，在栈顶的位置；所以，方法的执行的过程其实就是：栈帧创建、栈帧压栈和出栈的过程。结合前面的 PCG 我们可以更清楚的知道：当 CPU 要执行执行时，从<code>当前线程</code>的 PCG 去获取当前需要执行的 JVM 指令地址就是 <code>当前栈帧</code>。</p><p>有同学可能会问：如果在执行<code>当前方法</code>时，方法内部再去调用其他类的方法呢？ 同理，它新的栈帧就会被创建，然后被压如栈顶。直到方法执行结束再把栈顶的栈帧出栈。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>它是变量值的存储空间，用来存放方法的参数和方法中定义的局部变量。在 java 被编译成 class 文件时，该容量大小已经被明确；</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>它是一个栈，用来存储方法执行过程中往里面放元素，原则上，它可以是任意 java 类型。它也和局部变量表一样，在编译时已经确认其大小。</p><p>咦，前面刚明白了<code>局部变量表</code>用来存放变量的，怎么<code>操作数栈</code>也是用来存这些数据的呢？是不是有点迷糊？</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p><p>理解抽象？</p><p>举例吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog a = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">Animal b = <span class="keyword">new</span> Dog();</span><br></pre></td></tr></table></figure><p>在编译期 a 已经知道了自己‘是条狗’，但是 b 在编译期是不知道是狗还是猪。只有在运行期间才知道自己是条狗。</p><p>所以，这部分引用只有在运行期间才能转化的直接引用，称为动态链接。</p><h3 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h3><p>很好理解就是方法的正常返回和异常退出2种出口；</p><h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>堆是 java 内存的核心区域。也是 jvm 重点照顾的对象。用来存放 java 实例的，几乎所有的被创建的 java 实例和数组都被存放在此处。不同于前面2位是线程独有的，而堆是每个线程都共享的区域。其分为：新生代和老年代。</p><p>  我们可以在 jvm 启动的时候，通过<code>-Xxm:</code>来指定最大堆内存空间。</p><h2 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h2><p>是线程共享区域，用于存储元数据，比如类的结构信息，以及对应的运行时常量池、字段、方法代码等。在方法区内部还有一个<code>运行时常量池</code>，这里存储的时各种常量信息，不管是编译事情的字面量，还是运行期的符号引用。</p><p>早期大家喜欢把方法区称为永久代，但是从 JDK8 永久代就被 元数据区（Metaspace）取代了。</p><h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p>是线程私有的。顾名思义，是支持本地方法调用的。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="OOM场景有哪些？"><a href="#OOM场景有哪些？" class="headerlink" title="OOM场景有哪些？"></a>OOM场景有哪些？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆溢出：java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">栈溢出：java.lang.StackOverflowError</span><br><span class="line">永久代溢出：java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure><h2 id="那什么是OOM？会发生在哪些内存区域呢？"><a href="#那什么是OOM？会发生在哪些内存区域呢？" class="headerlink" title="那什么是OOM？会发生在哪些内存区域呢？"></a>那什么是OOM？会发生在哪些内存区域呢？</h2><p>通俗一点的说就是 JVM 内存不够用了， GC也不能提供更多的内存所以就报 OOM。所以，在 OOM 之前基本都会触发 GC。但是，也不是任何情况下 OOM 都会触发 GC。比如我们要分配一个超级大的数组其超过堆的最大值，JVM 会判断即使它调用了 GC 回收一次内存也无法给你分配你要的内存，所以，干脆直接报 OOM。</p><p>经过上面的了解，我们大致可以知道可能发生 OOM 有哪些区域：除了程序计数器之外，其他的任何区域都有可能发生 OOM。</p><ul><li>首先是<code>堆溢出: java.lang.OutOfMemoryError: Java heap space</code>。可能是堆内存泄露；或者是上面的例子，堆内存分配过小；程序问题导致 JVM 处理对象引用不及时，导致对象无法回收，内存堆积；</li><li>Java 虚拟栈和本地方法栈的<code>栈溢出：java.lang.StackOverflowError</code>。这个原因可能是我们程序有递归的方法，由于某种原因没有退出，而不停的压栈，导致栈溢出。我们还是知道在这个时候，如果 JVM 试图去扩展栈的大小，如果内存不够也会报 OOM，所以，就有时候为何无限递归也会报 OOM，原来如此啊。</li><li>老版 JDK（5，6或之前）因为永久代的大小是有限的，JVM 对永久代的 GC 不是很频繁，因为其存储的时一些常量和类信息，如果在一些运行期大量生产动态类型的场景，就可能报出<code>永久代溢出：java.lang.OutOfMemoryError: PermGen space</code>。但是，现在永久代已经被元数据区取代了，方法区内存就据说比之前增大了不少。先如果方法区报OOM会是：<code>元数据溢出：java.lang.OutOfMemoryError: Metaspace</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      这段时间又逼迫自己写东西了。本来想总结下线程方法的，但是发现线程涉及到太多的 JVM 内存方面的知识，所以，最近先把 JVM 相关知识复习下。
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://neilli.cn/tags/JVM/"/>
    
      <category term="内存" scheme="https://neilli.cn/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(8) - 谈谈 Java 的接口和抽象类</title>
    <link href="https://neilli.cn/2020/05/09/corejava-8-ci/"/>
    <id>https://neilli.cn/2020/05/09/corejava-8-ci/</id>
    <published>2020-05-09T02:47:16.000Z</published>
    <updated>2020-05-09T09:54:36.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面向对象和核心就是继承、多态、封装，而接口和抽象类就是它的2个基本的机制。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>它是抽象方法的集合，利用它可以很好的事项 API 和实现的分离；</li><li>不能实例化；</li><li>&lt;= Java8 不能有函数实现；</li><li>常亮只能是 public static final;</li><li>只能被实现；</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>不能实例化；</li><li>只能被继承；</li><li>可以有抽象方法和非抽象方法；</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>Java 相比于 C++ 其继承是不能多继承的。所以，有了这个局限性，我们在设计的时候，可以使用实现多个接口来达到多继承的目的。</p><p>Java 单继承陷阱：<br>设想下，如何在某些场景下，如果使用抽象类来抽象出基础逻辑，由于 Java 只能单继承，随时业务扩展，基类抽象的能力越来越多，导致某些<br>实现类不得不要去实现或空实现更多与自己无关的方法；</p><p>但是，如果使用接口，我们又可以设想下，如果能力都是用接口来定义，那么具体实现类要去实现接口定义的所有的方法，否则编译会出错；而此时如果我们<br>使用抽象类，里面的方法采用非抽象方法，那么子类就可以不用全部实现这些方法，只要按需重载即可。可见，这2者的选择是要自己根据自己的设计去抉择的。</p><p>在实际的工作当中，我们可以发现接口其实往往不仅仅是定义一些方法的集合。有些接口他一个方法都没有，就是一个空接口。那这类空接口是用来干啥的呢？</p><p>所以，它看起来和Annotation差不多吧。【思考：如何写个注解？】 但是Annotation可以指定参数和值，在表达能力上更易让程序员理解，可读性、美观上比较好，所以，大家更倾向于选择使用Annotation。</p><h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author neil</span><br><span class="line"> */</span><br><span class="line">@Documented</span><br><span class="line">@Constraint(validatedBy = MobileValidator.class)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Mobile &#123;</span><br><span class="line"></span><br><span class="line">    String message() default &quot;Invalid Mobile, &quot;;</span><br><span class="line"></span><br><span class="line">    Class[] groups() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class[] payload() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是定义个Mobile注解，用来 check 手机号是否合法的。具体各个字段的意义，大家自行了解。</p><h1 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h1><p>面向对象编程，必须要了解的设计中的基本原则（SOLID）：</p><ul><li>单一原则<ul><li>一个类只有单一职责</li></ul></li><li>开关原则<ul><li>修改关闭、扩展开放</li></ul></li><li>里氏替换<ul><li>凡是用来父类或基类的，都可以用子类替换之；</li></ul></li><li>接口分离<ul><li>接口不能定义太快方法，不然其子类就回陷入困难。因为它要实现此接口就必须实现此接口定义的与自己无关的方法。所以，在程序设计的时候，要把功能拆分成单一功能的多个接口，子类按需去实现不同接口。当某个单一功能的接口需要扩充是，则不会影响其他的接口和子类。</li></ul></li><li>依赖反转<ul><li>又叫依赖倒置，实体不能依赖实现，要依赖抽象。要面向抽象编程不能面向实现编程。</li></ul></li></ul><h2 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h2><p>比较难理解就是依赖反转了。其实我们都知道，简单举个例子。我们有个支付功能。有个实体类要用到支付功能，所以，它不能与AliPay或WxPay有依赖，要把支付抽象成PayInterface，AliPay和WxPay实现此接口，具体类要去和PayInterface有依赖关系即可。是不是很简单。这往往是面试中很多人不答不上来的。</p><p>在扩展一点还有【控制反转】【依赖注入】，后面我们学Spring的时候再深入吧。</p>]]></content>
    
    <summary type="html">
    
      在面试的时候，我也是很喜欢问这个问题，整体感觉下来，每个小伙伴回答的都一样，都很浅显，明显的时提起做了一些功课，但是回答的不够深入，用接口或抽象类结合面向对象去设计一个场景，往往不能很迅速的设计出来。
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
      <category term="面向对象" scheme="https://neilli.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>软件开发-版本号管理</title>
    <link href="https://neilli.cn/2020/04/09/version-rule/"/>
    <id>https://neilli.cn/2020/04/09/version-rule/</id>
    <published>2020-04-09T07:48:50.000Z</published>
    <updated>2020-04-09T07:58:02.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本号管理规范"><a href="#版本号管理规范" class="headerlink" title="版本号管理规范"></a>版本号管理规范</h1><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">说明</th><th style="text-align:center">版本号</th><th style="text-align:center">修订人</th><th style="text-align:center">日期</th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">全文</td><td style="text-align:center">1.0</td><td style="text-align:center">neil</td><td style="text-align:center">2019.04.09</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p><a name="FaPKF"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中台部门是一个公司的重要支撑部门，我们的服务能力要被各团队使用。所以，提供一个规范、可读性较强的版本号能很大程度减少关于Api版本号上的沟通，也更好的能针对特定版本的问题进行排查和沟通。<br><a name="a2cGK"></a></p><h1 id="命名格式"><a href="#命名格式" class="headerlink" title="命名格式"></a>命名格式</h1><p>项目版本号命名格式：<code>2.0.1.20200409_r2ae631e</code>，依次为：<code>主版本号</code>.<code>次版本号</code>.<code>发布版本号</code>.<code>日期</code> _ <code>希腊字母版本号</code> <code>git commit id</code><br></p><p><a name="XrbKJ"></a></p><h1 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h1><table><thead><tr><th style="text-align:center">名词</th><th style="text-align:center">详细说明</th></tr></thead><tbody><tr><td style="text-align:center">主版本号</td><td style="text-align:center"><code>里程碑</code>版本号，只有每次发布<code>里程碑</code>版本时才会改变</td></tr><tr><td style="text-align:center">次版本号</td><td style="text-align:center"><code>里程碑</code>版本号，只有每次发布<code>里程碑</code>版本时才会改变</td></tr><tr><td style="text-align:center">发布版本号</td><td style="text-align:center">每次更新时，在<code>里程碑</code>版本内，固定加1</td></tr><tr><td style="text-align:center">日期</td><td style="text-align:center">记录日期</td></tr><tr><td style="text-align:center">希腊字母版本号</td><td style="text-align:center"><code>希腊字母版本号</code>只有：<code>alpha</code>,<code>beta</code>,<code>pre</code>,<code>release</code>,<code>stable</code>，发布时分别对应<code>a</code>,<code>b</code>,<code>p</code>,<code>r</code>,<code>s</code>。<code>里程碑</code>版本发布前，内测版<code>希腊字母版本号</code>是<code>a</code>，公测是<code>b</code>，预发布是<code>p</code>,各个版本发布时是<code>r</code>，稳定版发布时是<code>s</code>，一般很少用。</td></tr><tr><td style="text-align:center">git commit id</td><td style="text-align:center">每次git提交时的id，发布时取当前最新的id的<code>前7位</code></td></tr></tbody></table><p><a name="N2sh2"></a></p><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><ul><li>以上规则适用于中台所有项目。</li><li><code>主版本号</code>.<code>次版本号</code>.<code>发布版本号</code>，在发布版本时，前面一位版本号改变时，后面版本号自动归<code>0</code>。</li><li><code>希腊字母版本号</code>，对于<code>a</code>版本，一般是开发者开发测试版本，一般不需要测试参与；<code>b</code>版本需要测试人员测试或公测。</li><li><strong>客户端显示只显示前3位版本号</strong>，即<code>主版本号</code>.<code>次版本号</code>.<code>发布版本号</code>。点击击版本号时，客户端弹出Dialog提示出详细版本信息，也可以根据各自开发、调试需要增加其他额外的详细信息。</li></ul>]]></content>
    
    <summary type="html">
    
      目前在负责公司微服务改造&amp;中台化建设，众多微服务的发布的版本号需要统一约束，故制定版本号管理规范，旨在减少不同部门对于Api和服务版本号的沟通，更让其具有一定可读性。
    
    </summary>
    
    
      <category term="中台" scheme="https://neilli.cn/categories/%E4%B8%AD%E5%8F%B0/"/>
    
    
      <category term="git" scheme="https://neilli.cn/tags/git/"/>
    
      <category term="版本管理" scheme="https://neilli.cn/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(7) - 从ConcurrentHashMap谈线程安全</title>
    <link href="https://neilli.cn/2019/12/22/corejava-7-concurrent/"/>
    <id>https://neilli.cn/2019/12/22/corejava-7-concurrent/</id>
    <published>2019-12-22T01:37:28.000Z</published>
    <updated>2020-04-21T02:18:35.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在前面讲了<code>HashMap</code>、<code>HashTable</code>我们对这样的键值对集合有一定的了解，今天我们再讲一个<code>线程安全</code>的集合：<code>ConcurrentHashMap</code>。然后分析下其实如何实现线程安全的呢？</p><p>Java为我们提供了很多方式来保证集合的线程安全。如：开箱即用的<code>HashTable</code>，以及使用<code>Collections.synchronizedMap</code>同步包装器来包装一个<code>HashMap</code>，还有就是<code>ConcurrentHashMap</code>的线程安全的<code>HashMap</code>。</p><p><code>HashTable</code>和<code>synchronizedMap包装器</code>返回的集合都是使用<code>synchronized</code>来实现对Map操作的线程安全的。这样的效率本身就是很低的，因为所有的并发都会去竞争同一把锁，也就是说当一个线程获得锁在执行时，其他线程只有等待了，因为这个锁已经被占用，这大大降低了效率。</p><p>综上，<code>HashTable</code>和<code>synchronizedMap包装器</code>是非常不适合高并发的场景下集合安全。</p><h1 id="ConcurrentHashMap源码"><a href="#ConcurrentHashMap源码" class="headerlink" title="ConcurrentHashMap源码"></a>ConcurrentHashMap源码</h1><p>上面说了那么多，就为了说明高并发下<code>ConcurrentHashMap</code>是比较适合的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the default initial table size (16).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with an initial table size</span></span><br><span class="line"><span class="comment">    * accommodating the specified number of elements without the need</span></span><br><span class="line"><span class="comment">    * to dynamically resize.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment">    * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                  MAXIMUM_CAPACITY :</span><br><span class="line">                  tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">       <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new map with the same mappings as the given map.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">       putAll(m);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment">    * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;) and</span></span><br><span class="line"><span class="comment">    * initial table density (&#123;<span class="doctag">@code</span> loadFactor&#125;).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">    * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment">    * given the specified load factor.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment">    * establishing the initial table size</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>它也有负载因子和容量，类的继承关系和HashMap一样，所以，其大致实现和HashMap是一样的，那我们之间看下其get和put源码，直接分析其是如何在高并发下实现线程安全的。</p><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><blockquote><p>为了方便，注释直接在源码添加。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多线程下key,value都不能为null。上一节给大家留的思考题。</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 首次put进行table初始化（Node&lt;K,V&gt;[] table）</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果此hash对于的value为null,则插入队未（见链表详解）</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">// 如果正在进行数组扩展，当前线程要help扩展（具体不去深究）</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此hash对应有值</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 同步</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<span class="comment">// 遍历当前存储元素的链表</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<span class="comment">// 要存储的key的hash在table中有重复</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)<span class="comment">// false: 替换当前key的value</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;<span class="comment">// 该节点下一个节点为空，则设置当前key,value为其下一个节点（即是队尾）</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">// 如果是红黑树类型</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;<span class="comment">// 将当前key,value插入树中</span></span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>想比较put操作，其get操作就很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其首先获取key的hash来确定此hash在table中位置，软化遍历此节点的所有元素得到value，通过源码可以看到，其读操作是支持并发的：</p><ul><li>没有使用同步；</li><li>没有使用unsafe；</li></ul><p>综上，ConcurrentHashMap的get操作是支持并发操作的，put是利用cas操作来保证其操作的安全性和高效性（1.7采用分段式的实现方案）；</p>]]></content>
    
    <summary type="html">
    
      HashMap到单Key,Value的存储，我们已经很很熟悉了，那么ConcurrentHashMap这个线程安全的Key,Value集合是如何做到线程安全的呢？
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
      <category term="线程安全" scheme="https://neilli.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(六)-谈谈你对Map的掌握-Java Map 源码分析</title>
    <link href="https://neilli.cn/2019/12/17/corejava-6-map/"/>
    <id>https://neilli.cn/2019/12/17/corejava-6-map/</id>
    <published>2019-12-17T09:13:23.000Z</published>
    <updated>2019-12-31T01:19:37.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上一节我们详细分析的集合，由于集合篇幅较长，我们吧<code>Map</code>单独拎出来分析下吧。也是由于从严格意义上说<code>Map</code>不能看出集合，但它又和集合有着很多联系，感觉有必要着重讲下。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>讲<code>HashMap</code>之前我们先大致了解下<code>红黑树</code>。</p><p><strong>什么是红黑树?</strong></p><p>简答来说其就二叉树的一种形式，不过其比二叉树更<code>智能</code>。它能左右平衡节点的数量，尽量保证树的高度差不多，所以红黑树的特点：</p><ol><li>节点只能是红色或黑色；</li><li>相邻的2个节点的颜色不能相同；</li><li>红色节点不能连续；</li><li>根节点、叶子节点都是黑色；</li><li>从任意节点到达其每一个叶子节点所有的路径经过的节点都是一样的；</li><li>时间算法复杂度<code>log(n)</code>；</li></ol><p>Java1.8中的<code>HashMap</code>就是引入了红黑树的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"> <span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">  * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">  * linked node.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">     TreeNode&lt;K,V&gt; left;</span><br><span class="line">     TreeNode&lt;K,V&gt; right;</span><br><span class="line">     TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">     <span class="keyword">boolean</span> red;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> r;</span><br><span class="line">             r = p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>具体红黑树的更多学习，简单的请参考下：<a href="https://www.javazhiyin.com/51677.html" target="_blank" rel="noopener">30分钟搞懂红黑树（图解）</a> .</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><code>HashMap</code>应该是我们在实际工作中使用最多的键值存储形式了。了解<code>HashMap</code>之前我们先了解下<code>HashTable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@since</span> JDK1.0</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@since</span>   <span class="number">1.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>从源码我们可以看出<code>Hashtable</code>是在早期Java提供的哈希表的一种实现。<br><code>Dictionary</code>抽象类定义了<code>HashTable</code>的一些基本操作，如：<code>增，删，取</code>等；加上<code>HashTable</code>本身是同步、线程安全的，而且其键和值不支持null，所以，我们开发时候选用的时候要注意。</p><p><strong>思考：为何HashTable的键和值都不能为null？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this hashtable maps one or more keys to this value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this method is identical in functionality to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #contains contains&#125; (which predates the &#123;<span class="doctag">@link</span> Map&#125; interface).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this hashtable is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException  if the value is &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if the specified object is a key in this hashtable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   possible key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if and only if the specified object</span></span><br><span class="line"><span class="comment">     *          is a key in this hashtable, as determined by the</span></span><br><span class="line"><span class="comment">     *          &lt;tt&gt;equals&lt;/tt&gt; method; &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException  if the key is &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #contains(Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而从Java1.2 之后设计的<code>HashMap</code>就是为了针对<code>HashTable</code>而改进的（也不能叫改进，各有场景吧）。</p><p><code>HashMap</code>进行<code>put</code>和<code>get</code>操作，其算法复杂度是<code>o(1)</code>，还记得之前集合的复杂度吗？</p><blockquote><p>再扩展讲下<code>TreeMap</code>，它是基于<code>红黑树</code>来实现的可以顺序访问的Map，其和<code>HashMap</code>不同，其<code>get</code>和<code>put</code>的时间复杂度是<code>O(logn)</code>。</p></blockquote><p>我们常常使用Map大多情况下都是使用增、删、取，都顺序是没有额外的要求的，这种情况<code>HashMap</code>是很好的选择，之前说了<code>HashMap</code>是哈希表的一种实现，所以其性能非常依赖哈希码的有效性，所以，又回到我们Java基础，掌握<code>equals</code>和<code>hashCode</code>;</p><ol><li>equal如果相等，hashcode一定要相等；</li><li>hashcode如果需要重写， 则equal也要重写；</li><li>equal要符合通用性（对称、传递、自反、一致）；</li></ol><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p><code>LinkedHashMap</code>和我们上一节学习的<code>LinkedList</code>差不多，都是一个双向链表，其遍历顺序和插入顺序是一样的。</p><p><img src="m.png" alt=""></p><p>我们可以看出<code>LinkedHashMap</code>继承<code>HashMap</code>，那它相对<code>HashMap</code>使用场景有什么特别呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns &lt;tt&gt;true&lt;/tt&gt; if this map should remove its eldest entry.</span></span><br><span class="line"><span class="comment">  * This method is invoked by &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;putAll&lt;/tt&gt; after</span></span><br><span class="line"><span class="comment">  * inserting a new entry into the map.  It provides the implementor</span></span><br><span class="line"><span class="comment">  * with the opportunity to remove the eldest entry each time a new one</span></span><br><span class="line"><span class="comment">  * is added.  This is useful if the map represents a cache: it allows</span></span><br><span class="line"><span class="comment">  * the map to reduce memory consumption by deleting stale entries.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Sample use: this override will allow the map to grow up to 100</span></span><br><span class="line"><span class="comment">  * entries and then delete the eldest entry each time a new entry is</span></span><br><span class="line"><span class="comment">  * added, maintaining a steady state of 100 entries.</span></span><br><span class="line"><span class="comment">  * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">  *     private static final int MAX_ENTRIES = 100;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *     protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span></span><br><span class="line"><span class="comment">  *        return size() &amp;gt; MAX_ENTRIES;</span></span><br><span class="line"><span class="comment">  *     &#125;</span></span><br><span class="line"><span class="comment">  * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This method typically does not modify the map in any way,</span></span><br><span class="line"><span class="comment">  * instead allowing the map to modify itself as directed by its</span></span><br><span class="line"><span class="comment">  * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify</span></span><br><span class="line"><span class="comment">  * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return</span></span><br><span class="line"><span class="comment">  * &lt;tt&gt;false&lt;/tt&gt; (indicating that the map should not attempt any</span></span><br><span class="line"><span class="comment">  * further modification).  The effects of returning &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">  * after modifying the map from within this method are unspecified.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This implementation merely returns &lt;tt&gt;false&lt;/tt&gt; (so that this</span></span><br><span class="line"><span class="comment">  * map acts like a normal map - the eldest element is never removed).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>    eldest The least recently inserted entry in the map, or if</span></span><br><span class="line"><span class="comment">  *           this is an access-ordered map, the least recently accessed</span></span><br><span class="line"><span class="comment">  *           entry.  This is the entry that will be removed it this</span></span><br><span class="line"><span class="comment">  *           method returns &lt;tt&gt;true&lt;/tt&gt;.  If the map was empty prior</span></span><br><span class="line"><span class="comment">  *           to the &lt;tt&gt;put&lt;/tt&gt; or &lt;tt&gt;putAll&lt;/tt&gt; invocation resulting</span></span><br><span class="line"><span class="comment">  *           in this invocation, this will be the entry that was just</span></span><br><span class="line"><span class="comment">  *           inserted; in other words, if the map contains a single</span></span><br><span class="line"><span class="comment">  *           entry, the eldest entry is also the newest.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>   &lt;tt&gt;true&lt;/tt&gt; if the eldest entry should be removed</span></span><br><span class="line"><span class="comment">  *           from the map; &lt;tt&gt;false&lt;/tt&gt; if it should be retained.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个方法上面的注释，详细说明了其应用场景：如果我们想要构造一个内存空间比较敏感资源池(类似线程池或redis的删除策略)，我们希望当资源池满了之后把最不常用或最先入池的数据删除，永远保证特定大小的资源池；</p><p>举例：我们想设计一个实时统计最近前100(n)名登陆的会员；如果我们用<code>LinkedHashMap</code>咋实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.neilli.corejava.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> neil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-12-18 10:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;Long, User&gt; top5 = <span class="keyword">new</span> LinkedHashMap&lt;Long, User&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Long, User&gt; eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"neil"</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2L</span>, <span class="string">"cici"</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3L</span>, <span class="string">"selly"</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4L</span>, <span class="string">"poly"</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">5L</span>, <span class="string">"nick"</span>);</span><br><span class="line"></span><br><span class="line">        top5.put(u1.getId(), u1);</span><br><span class="line">        top5.put(u2.getId(), u2);</span><br><span class="line">        top5.put(u3.getId(), u3);</span><br><span class="line">        top5.put(u4.getId(), u4);</span><br><span class="line">        top5.put(u5.getId(), u5);</span><br><span class="line"></span><br><span class="line">        top5.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"id: "</span> + k + <span class="string">", "</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        User user6 = <span class="keyword">new</span> User(<span class="number">6L</span>, <span class="string">"jare"</span>);</span><br><span class="line">        top5.put(user6.getId(), user6);</span><br><span class="line"></span><br><span class="line">        top5.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"id: "</span> + k + <span class="string">", "</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">long</span> id, String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            User user = (User) o;</span><br><span class="line">            <span class="keyword">return</span> id == user.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"id="</span> + id +</span><br><span class="line">                    <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">id: 1, User&#123;id=1, username=&apos;neil&apos;&#125;</span><br><span class="line">id: 2, User&#123;id=2, username=&apos;cici&apos;&#125;</span><br><span class="line">id: 3, User&#123;id=3, username=&apos;selly&apos;&#125;</span><br><span class="line">id: 4, User&#123;id=4, username=&apos;poly&apos;&#125;</span><br><span class="line">id: 5, User&#123;id=5, username=&apos;nick&apos;&#125;</span><br><span class="line">----------</span><br><span class="line">id: 2, User&#123;id=2, username=&apos;cici&apos;&#125;</span><br><span class="line">id: 3, User&#123;id=3, username=&apos;selly&apos;&#125;</span><br><span class="line">id: 4, User&#123;id=4, username=&apos;poly&apos;&#125;</span><br><span class="line">id: 5, User&#123;id=5, username=&apos;nick&apos;&#125;</span><br><span class="line">id: 6, User&#123;id=6, username=&apos;jare&apos;&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>改变<code>top5.put()</code>顺序，其输出也是会相应改变。</p><h3 id="再讲HashMap"><a href="#再讲HashMap" class="headerlink" title="再讲HashMap"></a>再讲HashMap</h3><p>为何要在这里再讲下<code>HashMap</code>呢？ 上面<code>LinkedHashMap</code>常见的例子中，我们假定是缓存Top100的当前会员，那我们在创建<code>LinkedHashMap</code>容器时能不能开始就确定你大小呢，前面章节中我们得知，动态数组的扩容是需要内存和性能的消耗的，那Map也一样。</p><p><code>LinkedHashMap</code>是继承自<code>HashMap</code>的，所以我们要分析下<code>HashMap</code>的源码，看下它们的容量是怎么玩的。</p><p><strong>容量</strong>和<strong>负载因子</strong>？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>通过上面的核心源码，我们明白了，如果像上面在<code>new LinkedHashMap()</code>时，其负载因子和容量都是默认值（0.75f、16）；</p><p>那上面的例子我们应该怎么设置<code>负载因子</code>和<code>容量</code>呢？</p><p>假如我们的预估数量是100，负载因子是0.75f。</p><p>下面源码是<code>put()</code>操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> * 返回一个比传入数值大的2的幂数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果size &gt; <code>threshold</code>，就会触发扩容(resize())，扩容到threshol的2倍；</p><p>那我们知道该如何设置容量了吧？</p><p>上面的例子，假如负载因子是0.75f，你的目标容量是100，那其应该是100/0.75 = 134，如果你设置<code>new HashMap(134)</code>，tableSizeFor会给你转成：<code>256</code>，那会有很多剩余，也会造成空间浪费和性能问题；</p><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>综上，我们可以分析得出HashMap内部可以看成一个数组和链表结合的符合结构，数据被分成一个一个的桶，哈希值决定了键值对在数组的位置，所以，理想情况下其操作复杂度是O(1); 但是，哈希值相同的键值对，则会以链表的形式来存储，当链表超过<code>TREEIFY_THRESHOLD</code>时，其又会变成树形结构，这样其复杂度就会被树化；</p><p>鉴于HashMap有这么一个’弱点’，那就可能被黑客利用DOS攻击，参考：<a href="http://vearne.cc/archives/34477" target="_blank" rel="noopener">哈希碰撞攻击与防范机制</a></p>]]></content>
    
    <summary type="html">
    
      Map,HashMap,LinkedHashMap,HashTable源码分析
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(五)-Java中的集合</title>
    <link href="https://neilli.cn/2019/12/16/corejava-5-list/"/>
    <id>https://neilli.cn/2019/12/16/corejava-5-list/</id>
    <published>2019-12-15T16:29:55.000Z</published>
    <updated>2019-12-16T08:12:33.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>集合，这个我们再熟悉不过了，我们应该用烂了吧。但是你真的很了解它吗？</p><p>说集合之前，肯定要撇不开它的’爸爸’ - 数组。</p><p>为何数组是集合的’爸爸’呢?</p><p>还记得前面章节我们提到的<code>自动拆箱和装箱</code>吗？ 在此之前，如果我们想要存放原始数据类型，我们只能用数组（想想为何?）。看出它诞生比较早&amp;&amp;比较重要吧，<br>但这还不算完，后面集合的设计也深深收到了数组的影响。</p><p>设计者们在开始之处就为数组设计成高效的存储和随机访问的能力，’上天’(设计者)不是万能的，高效的存储和随机访问，从而带来了它致命的硬伤 - 其长度是固定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] s1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">s1[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayIndexOutOfBoundsException</span></span><br><span class="line">s1[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们来总结下数组的特性，就能看出为何我们有需求要设计数组了。</p><ol><li>数组有高效的存储和随机访问能力；</li><li>数组只能存放一种类型数组；</li><li>数组的长度不可变；</li><li><p>数组是java中内置的数据类型，其存储的数据类型就是其自身类型，如：存储<code>User</code>，那数组自身就是<code>User</code>的数据（.getClass()），但，不代表其就和<code>User</code>一样的所有的类继承关系，有点绕~ ，看下例子应该就明白了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"neil"</span>, <span class="number">22</span>);</span><br><span class="line">        User[] users = <span class="keyword">new</span> User[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// class cn.neilli.corejava.list.User, class [Lcn.neilli.corejava.list.User;</span></span><br><span class="line">        System.out.println(user.getClass() + <span class="string">", "</span> + users.getClass());</span><br><span class="line">        <span class="comment">// class cn.neilli.corejava.list.Person, class java.lang.Object</span></span><br><span class="line">        System.out.println(user.getClass().getSuperclass() + <span class="string">", "</span> + users.getClass().getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>上面我们说了，有了<code>自动拆箱和装箱</code>之后，数据存储方式我们就有了集合。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>上面这样，是编译不通过的，必须是用Integer，也就是用到了我们前面说的<code>自动拆箱和装箱</code>功能。神奇吧。</p><p><strong>什么是集合?</strong></p><p>先上菜(网上找的) -&gt;</p><p><img src="jh.png" alt=""></p><p>通过上面经典的一个图，我们可以看出集合严格上说不包括Map，但是网上有很多讲集合也把Map涵盖进来，后面我们也会讲下这次关系。</p><p>什么是集合呢？讲集合，离不开<code>Vector</code>、<code>ArrayList</code>、<code>LikedList</code>3兄弟。<code>HashSet</code>由于比较简单和特殊，我们后面会带下。</p><p><code>Vector</code>、<code>ArrayList</code>、<code>LikedList</code>它们3个都有一个父类<code>AbstractList</code>，所以，它们功能比较类似、也是有序集合，都提供了同样的按位置进行定位、添加、删除元素和迭代器相关功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sole constructor.  (For invocation by subclass constructors, typically</span></span><br><span class="line"><span class="comment">     * implicit.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an iterator over the elements in this list in proper sequence.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation returns a straightforward implementation of the</span></span><br><span class="line"><span class="comment">     * iterator interface, relying on the backing list's &#123;<span class="doctag">@code</span> size()&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> get(int)&#125;, and &#123;<span class="doctag">@code</span> remove(int)&#125; methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that the iterator returned by this method will throw an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125; in response to its</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> remove&#125; method unless the list's &#123;<span class="doctag">@code</span> remove(int)&#125; method is</span></span><br><span class="line"><span class="comment">     * overridden.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation can be made to throw runtime exceptions in the</span></span><br><span class="line"><span class="comment">     * face of concurrent modification, as described in the specification</span></span><br><span class="line"><span class="comment">     * for the (protected) &#123;<span class="doctag">@link</span> #modCount&#125; field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an iterator over the elements in this list in proper sequence</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation returns &#123;<span class="doctag">@code</span> listIterator(0)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #listIterator(int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation returns a straightforward implementation of the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> ListIterator&#125; interface that extends the implementation of the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Iterator&#125; interface returned by the &#123;<span class="doctag">@code</span> iterator()&#125; method.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> ListIterator&#125; implementation relies on the backing list's</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> get(int)&#125;, &#123;<span class="doctag">@code</span> set(int, E)&#125;, &#123;<span class="doctag">@code</span> add(int, E)&#125;</span></span><br><span class="line"><span class="comment">     * and &#123;<span class="doctag">@code</span> remove(int)&#125; methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that the list iterator returned by this implementation will</span></span><br><span class="line"><span class="comment">     * throw an &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125; in response to its</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> remove&#125;, &#123;<span class="doctag">@code</span> set&#125; and &#123;<span class="doctag">@code</span> add&#125; methods unless the</span></span><br><span class="line"><span class="comment">     * list's &#123;<span class="doctag">@code</span> remove(int)&#125;, &#123;<span class="doctag">@code</span> set(int, E)&#125;, and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> add(int, E)&#125; methods are overridden.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation can be made to throw runtime exceptions in the</span></span><br><span class="line"><span class="comment">     * face of concurrent modification, as described in the specification for</span></span><br><span class="line"><span class="comment">     * the (protected) &#123;<span class="doctag">@link</span> #modCount&#125; field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看<code>AbstractList</code>源码可以知道，其迭代遍历是在这里实现的，所以它们这部分功能也是一样的。</p><p>既然说了那么多一样，又是<code>同根</code>，为何还要设计3个呢？</p><p>存在即合理。它们在线程安全和性能上是有不同的常见的。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the components of the vector are</span></span><br><span class="line"><span class="comment">     * stored. The capacity of the vector is the length of this array buffer,</span></span><br><span class="line"><span class="comment">     * and is at least large enough to contain all the vector's elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any array elements following the last element in the Vector are null.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of valid components in this &#123;<span class="doctag">@code</span> Vector&#125; object.</span></span><br><span class="line"><span class="comment">     * Components &#123;<span class="doctag">@code</span> elementData[0]&#125; through</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> elementData[elementCount-1]&#125; are the actual items.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The amount by which the capacity of the vector is automatically</span></span><br><span class="line"><span class="comment">     * incremented when its size becomes greater than its capacity.  If</span></span><br><span class="line"><span class="comment">     * the capacity increment is less than or equal to zero, the capacity</span></span><br><span class="line"><span class="comment">     * of the vector is doubled each time it needs to grow.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment">     * capacity increment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   initialCapacity     the initial capacity of the vector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   capacityIncrement   the amount by which the capacity is</span></span><br><span class="line"><span class="comment">     *                              increased when the vector overflows</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment">     * with its capacity increment equal to zero.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   initialCapacity   the initial capacity of the vector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty vector so that its internal data array</span></span><br><span class="line"><span class="comment">     * has size &#123;<span class="doctag">@code</span> 10&#125; and its standard capacity increment is</span></span><br><span class="line"><span class="comment">     * zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a vector containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this</span></span><br><span class="line"><span class="comment">     *       vector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        elementCount = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies the components of this vector into the specified array.</span></span><br><span class="line"><span class="comment">     * The item at index &#123;<span class="doctag">@code</span> k&#125; in this vector is copied into</span></span><br><span class="line"><span class="comment">     * component &#123;<span class="doctag">@code</span> k&#125; of &#123;<span class="doctag">@code</span> anArray&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  anArray the array into which the components get copied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the given array is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException if the specified array is not</span></span><br><span class="line"><span class="comment">     *         large enough to hold all the components of this vector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayStoreException if a component of this vector is not of</span></span><br><span class="line"><span class="comment">     *         a runtime type that can be stored in the specified array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #toArray(Object[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过源码，我们可以知悉：</p><ol><li>[大家都知道，不想复制源码了，自己看吧]线程安全；</li><li><code>protected Object[] elementData;</code> 本身是通过一个数组来存储数据的；</li><li><code>grow()</code> 其长度是可以动态扩充的，当不足时会通过<code>数组复制</code>来搞一个新的长数组(每次扩充是1倍的量)；</li></ol><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>看懂了<code>Vector</code>源码，其实ArrayList和其差不多，唯一不同的就是它没有线程安全、扩容的算法不一样；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">    * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>每次扩容是原长度的50%；</p><p>总结下ArrayList：</p><ol><li>比<code>vector</code>应用更广，建议(务必)没有线程安全要求时，不要用vector，可以考虑ArrayList；</li><li>动态扩容时，每次是原长度的50%；</li></ol><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>对的，你没看错，它存储数据不再是数组了，而是链表（双向）。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表相对于数据组存储数据而言，它是无序的，对内存空间的要求可以是非连续的。在计算中我们称zhe些非连续的内存块为<code>节点(Node)</code>。在单链表中节点不仅要存储数据，还要存储下一个节点的地址，这样就串成了一个链表；<br>大致如下：</p><p><img src="lb.png" alt=""></p><p>那双向链表就更方便了，每个node不仅要记录下一个node还要记录上一个node，也就是源码中的<code>first</code>、<code>last</code> Node；图就不画了，自己脑补。</p><p>那我们继续分析LinkedList源码，看下它是如何添加一个node的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先缓存原链表最后一个node</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 根据要添加的e创建一个新的node(前一个node是l)</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 把新node作为last node</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果原来链表为空，则新node也是first node</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 否则之前last node 的后一个node就是新node</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度++</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>add(), 默认是加在最后一个；</li><li>看上面的注释，应该好理解。</li></ol><p>那获取链表的具体位置的node，是咋玩的呢、？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查index合法性，其实就是看index是否小于0大于size；</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果index靠前就从头开始遍历，否则从维护遍历（设计巧妙啊）；</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的代码注释。可以看出其要获取某个node必须遍历链表长度的一半才能获得，但是这么做是为了其能更好的扩容。我们都知道连续的内存空间是通过CPU缓存来实现快速查找的，但是，天然就不具备连续性的链表显然不用使用到CPU的预读能力了，但是其本身突破了大小的限制，就是它的最大优势之一，也是其和那些数组存储的动态集合的最大区别；</p><p>链表的增、删的便利性往往是它的陷阱，建议开发者使用它的时候，要充分考虑你是否对内存要求很强。因为其相对于数组多出了指向相邻节点的指针，这就需要额外的内存。对列表的删除和插入也会造成整块的内存申请和释放，所以使用它的生活还是要慎重。</p><h3 id="HashSet、HashMap"><a href="#HashSet、HashMap" class="headerlink" title="HashSet、HashMap"></a>HashSet、HashMap</h3><p>这块相对简单，自己看下吧。有空我在更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;集合，这个我们再熟悉不过了，我们应该用烂了吧。但是你真的很了解它吗？&lt;/p&gt;
&lt;p&gt;说集合之前，肯定要撇不开它的’爸爸’ - 数组。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(四)-final深入解析</title>
    <link href="https://neilli.cn/2019/12/14/corejava-4-final/"/>
    <id>https://neilli.cn/2019/12/14/corejava-4-final/</id>
    <published>2019-12-14T06:19:42.000Z</published>
    <updated>2019-12-14T08:33:10.324Z</updated>
    
    <content type="html"><![CDATA[<p>前面章节中，我们详细讲了<code>String</code>、<code>int和Integer原始数据类型</code>里面都提到了<code>final</code>，那这个<code>final</code>到底有什么作用呢？</p><p>让我们google下看看？</p><p><img src="cj4-final.png" alt=""></p><p>看到了吧，网络上此类资料很多，写到这里我现在开始反思既然你要做一个java基础系统的分享培训，那此类资料很多很多，你又为何重新还要做呢？把这些资料归纳下、收集然后分发出去让他们学习不就好了吗？</p><p>讲真的，确实有过这样的想法。但是，真是因为网络上资料过于多种多样，如果一股脑的不加筛选的去汇总，会发现资料与资料直接可能存在冲突，而且有的可能分享的也不是很对(自己看来)，如果要详细筛选，那不如自己归纳总结，把自己认为是重点分享出来了，一则做一个系统的筛选和分享、二则可以巩固自己的知识。</p><p>所以，基于以上，<code>CoreJava</code>大概会有三十多节，我尽量在年前全部整理完成。年后开始<code>DDD</code>和<code>微服务</code>。</p><p>好了，废话不多说了。回到我们的正题：final到底是什么？</p><hr><h2 id="final-修饰"><a href="#final-修饰" class="headerlink" title="final 修饰"></a>final 修饰</h2><ol><li>final可修饰类</li><li>final可修饰方法</li><li>final可修饰变量</li></ol><p><strong>修饰类则代表其不可被继承、修饰方法则代表其不能被重写、修饰变量则代表其不可被修改</strong></p><p>思考题：</p><p>final修饰类型和方法好理解，但是修饰变量有点不好理解，请看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Integer b = <span class="number">2</span>;</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不在[-128,127]范围内</span></span><br><span class="line"><span class="keyword">final</span> Integer c = <span class="number">2000</span>;</span><br><span class="line">c = <span class="number">2001</span>;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> User u1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"neil"</span>);</span><br><span class="line">u1.setUsername(<span class="string">"neilli"</span>);</span><br><span class="line"></span><br><span class="line">User u2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"cici"</span>);</span><br><span class="line"></span><br><span class="line">u1 = u2;</span><br></pre></td></tr></table></figure><p>结合下我们之前将的基础数据类型以及其拆箱和装箱，思考下这4种情况会怎样？</p><p>相信你已经有答案了，上述结论：</p><ol><li>int是基础数据类型，不是对象，就对应一个值，如果其是final的则表示其不可修改；</li><li>Integer我们之前章节讲过，也分析过源码，其内部有个value，仔细看代码的小伙伴发现了value是final的int，所以，无论其是否使用了<code>IntegerCache</code>其都是无法修改的；</li><li>final如果修饰一个对象，则对象里面的值是可以任意修改的，但是不可以把<code>u2</code>的引用赋值给<code>u1</code>,也就是说final的<code>u1</code>其内存引用是不可改变的。</li></ol><p>这下子世界清静了吧？那再来个思考题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">"neil"</span>);</span><br><span class="line">list1.add(<span class="string">"cici"</span>);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;String&gt; list2 = List.of(<span class="string">"neil"</span>, <span class="string">"cici"</span>);</span><br><span class="line">list2.add(<span class="string">"selly"</span>)</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>好吧。你或许已经知道了<code>List.of()</code>的用法了，它就是为了获取一个<code>immutable</code>的List。<br>这里我们再次接触了<code>immutable</code>，第一次接触它我们是在<code>String、StringBuffer、StringBuilder章节</code>中得知，让我们再结合下<code>final</code>再回顾下什么是<code>immutable</code>，如何实现<code>immutable</code>类，回想下String这个特殊的类:</p><ol><li>显然只有<code>final</code>其不等价于<code>immutable</code>，上面很多例子已经证明；</li><li>class必须是final的，这样无法再被继承了；</li><li>class的所有的成员变量都是private final类型的，而且不能实现<code>setter</code>方法，也最好不要实现<code>getter</code>方法；</li><li>构造对象时，变量使用深拷贝而不是使用直接赋值；</li></ol><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>参考阅读：<a href="https://juejin.im/post/5de7237a518825125015cd6d" target="_blank" rel="noopener">Java 浅拷贝、深拷贝，你知多少？</a></p><p>好了，final就到这里吧。<br>后面的实际工作当中我们用到它的机会还有很多很多，比如在匿名内部类里面引用局部变量时，其必须是final类型的等等；</p><p>到时候我们再专门讲吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面章节中，我们详细讲了&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;int和Integer原始数据类型&lt;/code&gt;里面都提到了&lt;code&gt;final&lt;/code&gt;，那这个&lt;code&gt;final&lt;/code&gt;到底有什么作用呢？&lt;/p&gt;
&lt;p&gt;让我们google下看看
      
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(三)-原始数据类型之int</title>
    <link href="https://neilli.cn/2019/12/13/corejava-3-int/"/>
    <id>https://neilli.cn/2019/12/13/corejava-3-int/</id>
    <published>2019-12-13T07:22:34.000Z</published>
    <updated>2019-12-14T06:35:44.531Z</updated>
    
    <content type="html"><![CDATA[<p>学过Python的都知道，Python也是一个面向对象的语言，Python也号称<code>一切皆对象</code>，因为其类、函数都可以看做成对象，其也没有像Java中原始数据类型的概念。所以，从这个角度看，Python的对象化比Java更彻底。</p><p>那我们说说Java的原始数据类型。</p><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>Java原始数据类型有8种，分别如下：</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul><li>byte - 8位 - 1字节</li><li>short - 16位 - 2字节</li><li>int - 32位 - 4字节</li><li>long - 64位 - 8字节</li></ul><h3 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h3><ul><li>float - 32位 - 4字节</li><li>double - 64位 - 8字节</li></ul><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul><li>char - 16位 - 2字节</li></ul><h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><ul><li>boolean - true/false - N</li></ul><p>为了更深入的去了解原始数据类型和其包装类，我们今天就单独针对int来详细剖析下。</p><h2 id="int-和-Integer"><a href="#int-和-Integer" class="headerlink" title="int 和 Integer"></a>int 和 Integer</h2><p>int是java的原始数据类型，Integer是其封装类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant holding the minimum value an &#123;<span class="doctag">@code</span> int&#125; can</span></span><br><span class="line"><span class="comment">     * have, -2&lt;sup&gt;31&lt;/sup&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MIN_VALUE = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant holding the maximum value an &#123;<span class="doctag">@code</span> int&#125; can</span></span><br><span class="line"><span class="comment">     * have, 2&lt;sup&gt;31&lt;/sup&gt;-1.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MAX_VALUE = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Class&#125; instance representing the primitive type</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">"int"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a newly allocated &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">     * represents the specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   value   the value to be represented by the</span></span><br><span class="line"><span class="comment">     *                  &#123;<span class="doctag">@code</span> Integer&#125; object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a newly allocated &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">     * represents the &#123;<span class="doctag">@code</span> int&#125; value indicated by the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> String&#125; parameter. The string is converted to an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> int&#125; value in exactly the manner used by the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> parseInt&#125; method for radix 10.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      s   the &#123;<span class="doctag">@code</span> String&#125; to be converted to an</span></span><br><span class="line"><span class="comment">     *                 &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  NumberFormatException  if the &#123;<span class="doctag">@code</span> String&#125; does not</span></span><br><span class="line"><span class="comment">     *               contain a parsable integer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.lang.Integer#parseInt(java.lang.String, int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = parseInt(s, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br></pre></td></tr></table></figure><p>通过源码可以看到Integer里面有个int类型的value来负责存储数据，其也提供了像toString,parseInt以及数据运算的功能。</p><p>value是final，这是不可变的写法，后面我们会专门讲final。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment"> * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment"> * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment"> * caching frequently requested values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Java1.5</code>时添加d valueOf() ，也同时增加了一个<code>IntegerCache</code>的概念。</p><p>Integer可以看成一个类型，想要创建这个类型的实例(Java1.5之前)，我们可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer age = <span class="keyword">new</span> Integer(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样的方式来创建，但是从1.5之后，我们就可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer age = Integer.valueOf(<span class="number">20</span>);</span><br><span class="line">或</span><br><span class="line">Integer age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>仔细看源码就能发现这个<code>IntegerCache</code>, 它能缓存-128到127的数值。所以，用valueOf来获取Integer对象明显是比直接new 高效也省内存的。</p><h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><ol><li>什么是自动装箱和自动拆箱？</li><li>它们如何实现的呢？</li></ol><p>顾名思义，装，就是把原始数据类型转换成其包装类的实例；拆，则反过来；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer age = <span class="number">20</span>; <span class="comment">// 装箱</span></span><br><span class="line">Integer age = Integer.valueOf(<span class="number">20</span>); <span class="comment">// 装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age2 = age; <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><p>那自动装箱和拆箱是如何实现的呢？我们可以通过javac和javap命令来看下其装箱和拆箱的过程；</p><blockquote><p>javac 是讲我们的源java文件编译成字节码，而javap则是把我们不可读的字节码反编译成我们可以读的文件。</p></blockquote><p>直接上结果了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Integer age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> age2 = age;</span><br><span class="line"></span><br><span class="line">       System.out.println(age);</span><br><span class="line">       System.out.println(age2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们测试自动装箱和拆箱的Java源文件，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac Test.java</span><br></pre></td></tr></table></figure><p>之后，会生成一个.class文件</p><p><img src="class.png" alt=""></p><p>.class文件是字节码，我们是无法阅读的，借助：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c Test</span><br></pre></td></tr></table></figure><p>得到</p><p><img src="javap.png" alt=""></p><p>很清晰的可以看出在自动装箱和拆箱分别通过<code>valueOf()</code>和<code>intValue()</code>来实现。</p><p>通过上面的的详细分析，你会感觉java的自动装箱和拆箱很酷，但是，我们应该在实际的业务中避免无意的装箱和拆箱行为，因为相对于大量的对象和数据，其性能有很显著的差异。所以，在实际工作中能用原始类型替换封装类和动态数组的进行替的坚决不用封装类；</p><h2 id="源码扩展"><a href="#源码扩展" class="headerlink" title="源码扩展"></a>源码扩展</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment"> * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment"> * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment"> * caching frequently requested values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>IntegerCache</code>你应该还记得，其是缓存数组的实现，但是你好像只能缓存-128~127的数值啊，但是其doc说明了，它还可以缓存超出此范围的数值呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* This method will always cache values in the range -128 to 127,</span><br><span class="line">* inclusive, and may cache other values outside of this range.</span><br></pre></td></tr></table></figure><p>这是怎么回事呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原来 JVM给我们提供一个可以调整缓存上线的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:AutoBoxCacheMax=1000</span><br></pre></td></tr></table></figure><p>出个课后作业：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer a1 = <span class="number">20</span>;</span><br><span class="line">Integer a2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">Integer b1 = <span class="number">20000</span>;</span><br><span class="line">Integer b2 = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">a1 == a2 ?</span><br><span class="line">b1 == b2 ?</span><br></pre></td></tr></table></figure><hr><p>好了，以上是我们专门针对int这个原始数据类型做的详细剖析，其他的类型基本和这个类似，像<code>valueOf</code>和<code>xxxValue</code>都是一样的，它们也有<code>XXXCache</code>(如：short，具体哪些有哪些没有，自己研究下吧)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>数值类型的原始数据类型是有取值范围的(上面已经表明)，以int为例，如果2个较大的数相乘，要避免超出范围；</li><li>优先使用原始数据类型，避免无意中的拆箱和装箱；</li><li>如果有线程安全的则考虑相应的线程安全的实现（线程安全后面专门来梳理）；</li><li>java自动拆箱和装箱，作为我们普通开发者来说，无需过于注意；</li></ol>]]></content>
    
    <summary type="html">
    
      Java,原始数据类型,原始数据类型的大小,原始数据类型的取值范,Int,Integer
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(二)-谈谈你对String、StringBuilder、StringBuffer的理解</title>
    <link href="https://neilli.cn/2019/12/12/corejava-2-string/"/>
    <id>https://neilli.cn/2019/12/12/corejava-2-string/</id>
    <published>2019-12-12T11:18:26.000Z</published>
    <updated>2019-12-14T06:02:02.067Z</updated>
    
    <content type="html"><![CDATA[<p>字符串，在任何语言、任何平台中都是最常见的，它也是最重要的。回顾下你的项目是不是感觉他无处不在？它是不是应用最多？无论是声明的数量还是其占用的体积。</p><h3 id="基于源码分析"><a href="#基于源码分析" class="headerlink" title="基于源码分析"></a>基于源码分析</h3><p>String,  java.lang 包下。 以下以1.8为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">     * &lt;a href="&#123;<span class="doctag">@docRoot</span>&#125;/../platform/serialization/spec/output.html"&gt;</span></span><br><span class="line"><span class="comment">     * Object Serialization Specification, Section 6.2, "Stream Elements"&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><ol><li>是final类，典型的Immutable类型；</li><li>除hash其他属性全部final(可以看做其所有属性都是final的)；</li><li>由于其不可变性，如果对字符串进行拼接、裁剪等都会产生新的对象，这往往会对性能有影响，所以就会引申出StringBuilder和StirngBuffer.</li></ol><p>StringBuffer,  java.lang 包下。 以下以1.8为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment">     * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3388685877147921107L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a string buffer with no characters in it and an</span></span><br><span class="line"><span class="comment">     * initial capacity of 16 characters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a string buffer with no characters in it and</span></span><br><span class="line"><span class="comment">     * the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      capacity  the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  NegativeArraySizeException  if the &#123;<span class="doctag">@code</span> capacity&#125;</span></span><br><span class="line"><span class="comment">     *               argument is less than &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>细心的小伙伴已经看到了，StringBuffer也是final修饰的，为何他就能修改呢？那是因为其通过可修改数组实现且不String是final的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment"> * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure><p>而且通过继承<code>AbstractStringBuilder</code>包含了其所有的基本操作。StringBuilder相对于StirngBuffer是少了一个<code>synchronized</code>，其他的都一样。</p><p>那大概是这样的，<code>StringBuffer</code>为了解决对String字符串的操作带来的新创建对象问题而专门设计的一个类。我们可以使用其<code>append</code>和<code>add</code>来对字符串进行操作。<br><code>StringBuffer</code>本质上是一个线程安全的可修改的字符串序列（<strong>思考：其如何实现线程安全的？</strong>），为了保证线程安全必然会造成额外的性能开销，正因如此<code>Java1.5</code>中新增了<code>StringBuilder</code>，来解决此问题。所以，只要不涉及到线程安全问题，我们一般都建议使用<code>StringBuilder</code>，切记。</p><h3 id="思考分析"><a href="#思考分析" class="headerlink" title="思考分析"></a>思考分析</h3><p>上面基于源码，我们已经大致知道String,StringBuffer,StringBuilder是怎么回事了。这个是我们java开发中基础中的基础，是务必要掌握的，也是写出高质量代码的核心。</p><p>那我们就可以理解java对内存、对象声明、线程安全是非常讲究的。</p><p>上面也说了，直接对String操作会带来新对象的创建，进而会对内存、性能产生影响，那结合上一节中我们说的jvm，<strong>思考：jvm对内存和性能的管理是怎样的呢？还有，StringBuiffer是如何设计成线程安全的？能不能谈谈你对线程安全的基本原理，进而设计和实现出呢？</strong></p><p>通过上面的源码我们可以看到，StringBuilder和StringBuffer为了实现可变，都是在底层添加了一个数组（好像Java9是Byte了，具体我没玩过），那我们第一时间就会思考，这个数组要定多大呢？源码中告诉我们是<code>x+16</code>，也就是说如果开始你没传入要构建的字符串，那初始size就是16。扩容时会把把原来的数组摒弃掉，然后重新创建一个x+16 size的数组，然后进行<code>arraycopy</code>，这不就很浪费很耗费性能和内存了吗？追求代码极致的我们怎么能容忍这样的事情出现呢？<br>所以，我们要使用StringBuilder和StringBuffer如果提前能知悉大小，一定要先设置大小，避免多次扩容。</p><p>好了，感觉String已经说的差不多了。想下上面的思考题吧。知识有限，如有误，请指教。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符串，在任何语言、任何平台中都是最常见的，它也是最重要的。回顾下你的项目是不是感觉他无处不在？它是不是应用最多？无论是声明的数量还是其占用的体积。&lt;/p&gt;
&lt;h3 id=&quot;基于源码分析&quot;&gt;&lt;a href=&quot;#基于源码分析&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://neilli.cn/tags/JVM/"/>
    
      <category term="线程安全" scheme="https://neilli.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CoreJava(一)-如何给别人讲述下你所理解的Java平台？</title>
    <link href="https://neilli.cn/2019/12/12/corejava-1/"/>
    <id>https://neilli.cn/2019/12/12/corejava-1/</id>
    <published>2019-12-12T07:28:00.000Z</published>
    <updated>2020-09-15T00:50:56.904Z</updated>
    
    <content type="html"><![CDATA[<p>2010年开始接触java，2011年9月开始转到Android，后来又转做后端Python、PHP和自己玩些前端。接触java也许久了，随着公司业务发展需要新团队技术栈选型使用Java，团队中有些后端是从PHP、Python转过来的，也有些是新入职的。基于以上，决定把之前的CoreJava再次系统梳理下，做一个专题进行持续分享。</p><p>好了，回到我们的分享的课题。</p><p>本身这是一个开放的命题，做这个专题也是为了给那些从其他语言转过来的以及新来的小伙伴起个抛砖引玉的作用，引导其探索的分享，所以，就从自己认知说起吧。</p><p>Java，对其第一反应有哪些？面向对象、垃圾回收、JVM、JDK、JRE、JAVAC、跨平台、面向对象、反射、泛型… 还有java周边生态、工具等等</p><h3 id="Java两个显著特征"><a href="#Java两个显著特征" class="headerlink" title="Java两个显著特征"></a>Java两个显著特征</h3><ol><li>跨平台能力（Write Once, Run AnyWhere）；</li><li>垃圾回收（GC）；</li></ol><p>思考题：为何Java有跨平台能力？</p><h3 id="Java是解释执行的？"><a href="#Java是解释执行的？" class="headerlink" title="Java是解释执行的？"></a>Java是解释执行的？</h3><p>对于Java是解释型语言还是编译型语言，大家可以参考 <a href="https://blog.csdn.net/qzc70919700/article/details/72515022" target="_blank" rel="noopener">Java到底是编译型语言还是解释型语言？</a> 这篇文章，个人认为分析的还是很容易懂的(本身就很好懂好吧~)。<br>基于此文结论：java是解释型语言，是否就可以理解java是解释执行的呢？为什么呢？可能好多人都对这个有疏忽，个人分析如下（知识有限，如回答有误私聊赐教）：</p><ol><li>我们编写的java源文件通过javac编译成字节码，然后jvm的解释器将字节码转换成最终可被识别的机器码。</li><li>我们常见JVM（如<a href="https://zh.wikipedia.org/wiki/HotSpot" target="_blank" rel="noopener">HotSpot</a>），是用JIT技术（Just-in-time compilation）。通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。JIT是包含两者，对于大部分代码JVM会采用动态编译，但是JIT会对java的热点代码编译成机器码，对于这部分已经编译成机器码的热点代码它们就不是解释执行了，可以看作编译执行，这或许就是JIT的能提高程序运行效率所在吧。</li></ol><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM本身是一个非常强大的平台，不仅java能运行在上面，本质上只要是标准的字节码都能在上面运行。比如：Groovy（其他的如Jython，JRuby没玩过）；</p><p>由于我们不是专门去详细介绍JVM，而是针对部门的系列分享，不可能吧JVM在这边梳理的那么清晰，当然网络上这部分资料也很多。<br>推荐：周志明的《深入理解Java虚拟机》这本书，由浅入深的讲述的应该比较好，个人对此深入不够，后面也会专门对这块恶补。<br>但是，建议学习java还是要对jvm的基本概念和机制有所了解。比如：java的类加载机制，常见的jdk8中的class-loader。class的大致过程：加载、验证、链接、初始化；对自定义classloader有所了解，即使在实际项目中可能用不到；<br>垃圾回收原理，常见的垃圾回收器：SGC、PGC、CMS、G1等，</p><h3 id="JRE-amp-JDK"><a href="#JRE-amp-JDK" class="headerlink" title="JRE&amp;JDK"></a>JRE&amp;JDK</h3><p>JRE（Java Runtime Environment），包含了java类库和jvm，和一些其需要的模块。<br>JDK（Java Development Kit），我们可以把jdk看作成jre的超级，其提供了更多的工具，比如编译器、各种诊断工具，例如：javac，jmap，jstack等。</p><p>进行java开发，对jdk要充分熟悉，就像做android开发要非常熟悉sdk一样。大致：编译器、安全工具、运行环境、诊断和监控工具等；都是是后续开发效率提升的保证。不只是android，其他语言如Python、PHP也一个道理。</p><h3 id="Java知识图谱"><a href="#Java知识图谱" class="headerlink" title="Java知识图谱"></a>Java知识图谱</h3><p>上面罗列了一些名词，只是别人刚问你java平台啥，我们可能的第一反应，但是要想有更全面的知识覆盖，建议每个人都去画下java的图谱，我也会在后面慢慢补上我自己的，然后分享出来。</p><hr><p>今天只是粗略的分享了java平台大致的样子，不求对细节理解多深入，但要求对文中提到的店还是要下点功夫。</p><p>总结：java语言特性、核心类库、第三方类库、jvm；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2010年开始接触java，2011年9月开始转到Android，后来又转做后端Python、PHP和自己玩些前端。接触java也许久了，随着公司业务发展需要新团队技术栈选型使用Java，团队中有些后端是从PHP、Python转过来的，也有些是新入职的。基于以上，决定把之前
      
    
    </summary>
    
    
      <category term="Java" scheme="https://neilli.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://neilli.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://neilli.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JWT结合Redis实现授权认证方案</title>
    <link href="https://neilli.cn/2019/12/09/jwt-redis-auth/"/>
    <id>https://neilli.cn/2019/12/09/jwt-redis-auth/</id>
    <published>2019-12-09T10:39:55.000Z</published>
    <updated>2020-06-03T09:24:54.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><p>JWT我们都很清楚了，在实战中不止一次使用。其原理简单描述就是：认证服务器吧一串json加密之后返回给应用，就像这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"230012"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"neilli"</span>,</span><br><span class="line">  <span class="attr">"exprie_data"</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjIzMDAxMiIsIm5hbWUiOiJuZWlsbGkiLCJleHByaWVfZGF0YSI6MTUxNjIzOTAyMn0.WXgPJeoK89bzR1gWPVRe_mAz91TOzMqVMcv4wAbulew</span><br></pre></td></tr></table></figure></p><p>应用获取加密后数据之后，再次请求服务的生活带上上述加密的字符串即可。服务端根据秘钥去获取用户认证的身份。这样服务端就不需要保持<code>session</code>了，也就是说服务的变成了无状态的了，从而比较容易实现扩展；</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>JWT之所以是无状态的，就是其用户身份只根据上面的秘钥来确定，也就是一旦<code>令牌</code>签发，则其就不受服务端控制，其消亡只能根据<code>令牌</code>本身的过期时间来控制，这样对于有一些实时性要求的系统来说是不可行的。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><blockquote><p>要解决上述的问题，本身有很多方案，下面就简单实用redis来说明解决方案。</p></blockquote><p><img src="j-r-a.png" alt=""></p><ol><li>授权服务器接收到应用请求，去用户表获取授权信息；</li><li>根据业务，生成jwt换成到redis，并返回redis 换的key（32或64位）；</li><li>应用获取access_token缓存起来，再次请求时带上access_token；</li><li>网关接受到access_token，去redis获取jwt并校验；</li><li>网关之后的服务直接鉴权都实用jwt；</li><li>如果需要实时清楚jwt，则在网关处去校验授权是否合法，清除redis即可；</li></ol><hr><p>PS: 细心的小伙伴还发现了<code>认证服务器</code>是单独的，这个根据自己实际业务决定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JWT原理&quot;&gt;&lt;a href=&quot;#JWT原理&quot; class=&quot;headerlink&quot; title=&quot;JWT原理&quot;&gt;&lt;/a&gt;JWT原理&lt;/h2&gt;&lt;p&gt;JWT我们都很清楚了，在实战中不止一次使用。其原理简单描述就是：认证服务器吧一串json加密之后返回给应用，就像这样
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://neilli.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="https://neilli.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="JWT" scheme="https://neilli.cn/tags/JWT/"/>
    
      <category term="Redis" scheme="https://neilli.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>弄懂SpringBoot中过滤器、拦截器、监听器</title>
    <link href="https://neilli.cn/2019/11/26/filter-interceptor/"/>
    <id>https://neilli.cn/2019/11/26/filter-interceptor/</id>
    <published>2019-11-26T02:33:59.000Z</published>
    <updated>2019-11-26T09:00:07.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对开始刚玩SpringBoot的同学来说光这个几个概念就够理解的了~ 更别说其原理、区别以及使用了，我也是在具体用到的时候才发现确实有点绕，在后面开发的时候肯定少不了和其打交道，所以，在此总结下。</p></blockquote><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p><code>监听器 &gt; 过滤器 &gt; 拦截器</code></p><h2 id="它们是怎么使用的？"><a href="#它们是怎么使用的？" class="headerlink" title="它们是怎么使用的？"></a>它们是怎么使用的？</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p><strong>实现方式：</strong></p><ol><li>[建议]实现<code>HandlerInterceptor</code>接口；</li><li>继承<code>abstract HandlerInterceptorAdapter</code>;</li></ol><p><strong>具体方法(HandlerInterceptor)：</strong></p><ol><li>preHandle()</li><li>postHandle()</li><li>afterCompletion()</li></ol><blockquote><p>按单词意思即可理解其意，preHandle() 返回<code>true</code>才会往下走；</p></blockquote><p><strong>如何用Interceptor来实现部分请求无需登录校验？</strong></p><blockquote><p>用<code>filter</code>可以添加无需登录校验的<code>api</code>，但，我们也可以用<code>Interceptor</code> + <code>注解</code>的形式，来<br>自定义一个<code>@AnonymousAllow</code>的注解，来拦截网络请求，判断其是否需要登录校验，这样做是不是另外一种思路？具体如下：</p></blockquote><h4 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnonymousAllow &#123;</span><br><span class="line">    <span class="comment">// 接口允许匿名访问</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">anonymousAllow</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现AuthorizationInterceptor"><a href="#实现AuthorizationInterceptor" class="headerlink" title="实现AuthorizationInterceptor"></a>实现AuthorizationInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        AnonymousAllow anonymousAllow = handlerMethod.getMethod().getAnnotation(AnonymousAllow.class);</span><br><span class="line">        <span class="keyword">if</span> (anonymousAllow != <span class="keyword">null</span> &amp;&amp; anonymousAllow.anonymousAllow()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String authorization = request.getHeader(AuthConstants.AUTHORIZATION);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(authorization)) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            log.error(<span class="string">"AuthorizationInterceptor preHandle SC_UNAUTHORIZED: Null"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtil.verifyToken(authorization);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"AuthorizationInterceptor preHandle verifyToken Error: "</span> + e.getMessage());</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnonymousAllow</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserResponse <span class="title">login</span><span class="params">(@Valid @RequestBody LoginForm form)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>像上面一样，只要在具体不需要登录校验的接口处添加<code>@AnonymousAllow</code>注解即可；</p></blockquote><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="以zuul网关来举例，具体如下："><a href="#以zuul网关来举例，具体如下：" class="headerlink" title="以zuul网关来举例，具体如下："></a>以<code>zuul</code>网关来举例，具体如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterType.PRE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"AuthorizationFilter zuul filter"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以SpringCloud-gateway为例，具体如下："><a href="#以SpringCloud-gateway为例，具体如下：" class="headerlink" title="以SpringCloud gateway为例，具体如下："></a>以<code>SpringCloud gateway</code>为例，具体如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UnAuthCheckConfig unAuthCheckConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.secret:xz-jwt-test&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        String path = exchange.getRequest().getURI().getPath();</span><br><span class="line">        log.info(<span class="string">"AuthFilter path:"</span> + path);</span><br><span class="line">        <span class="comment">// 放掉不需要authcheck的路由</span></span><br><span class="line">        <span class="keyword">if</span> (unAuthCheckConfig.getUnAuthRequestList().contains(path)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String authorization = exchange.getRequest().getHeaders().getFirst(AuthConstants.AUTHORIZATION);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(authorization)) &#123;</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtil.verifyToken(authorization, secret);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">"Jwt verifyToken Error: "</span> + e.getMessage());</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><h4 id="仅以HttpSessionListener为例，实现如下："><a href="#仅以HttpSessionListener为例，实现如下：" class="headerlink" title="仅以HttpSessionListener为例，实现如下："></a>仅以<code>HttpSessionListener</code>为例，实现如下：</h4><blockquote><p>监听网址实时在线人数，比如当前登录此博客有多少人，兼容<code>session</code>过期时间为30min，这个是如何实现的呢（方案不止一种）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineSessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建~ 统计 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 销毁~ 统计 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>把此监听器加入到<code>spring容器</code>中，即可实现对<code>session</code>的监听；</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>经过上面的几种简单的实现，我们应该对其有个基本的了解了~再回过头看下之前给出的他们的执行顺序：<code>监听器 &gt; 过滤器 &gt; 拦截器</code>，为何是这样的？</p><p>经过上面的实现，我们看到<code>拦截器</code>是必须依赖<code>SpringMVC控件</code>(<code>WebMvcConfigurer</code>)，而且其必须作用在<code>servlet</code>里面，因为其对<code>controller</code>进行拦截；</p><p>而<code>拦截器</code>是针对<code>request（response）</code>进行拦截，依赖<code>servlet容器</code>；</p><p><code>监听器</code>是<code>servlet中特殊的类</code>，能帮助我们监听web中特定的事件，比如：请求域、session、applicaiton；</p><p>综上：</p><ol><li>过滤器(filter)依赖servlet容器，只能在servlet容器(web)下使用；</li><li>拦截器(interceptor)依赖springMVC框架，是在spring框架下使用，不局限web环境；</li><li>监听器(springboot使用的)，只能在web下使用；</li><li>filter实现<code>dofilter</code>回调（所以，必须在servlet容器才能回调过来）；</li><li>interceptor是基于反射，所以，和servlet无关；</li><li>interceptor只能对controller请求进行过滤，action之前开始，action结束则intercepor结束；</li><li>filter不仅能过滤请求，还能对静态资源进行保护和过滤；</li><li>interceptor能访问action的上下文（例中获取注解）；</li><li>interceptor可以在controller一个生命周期内被多次调用（只能针对controller）;</li><li>filter在容器初始化的时候只会被执行一次；</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>filter可以过滤任何请求，但是只能被执行一次；</li><li>interceptor可以多次执行，但是只能针对controller；</li><li>listener是针对整个应用特殊事件进行监听；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对开始刚玩SpringBoot的同学来说光这个几个概念就够理解的了~ 更别说其原理、区别以及使用了，我也是在具体用到的时候才发现确实有点绕，在后面开发的时候肯定少不了和其打交道，所以，在此总结下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://neilli.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="SpringBoot" scheme="https://neilli.cn/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://neilli.cn/tags/SpringCloud/"/>
    
      <category term="Filter" scheme="https://neilli.cn/tags/Filter/"/>
    
      <category term="Interceptor" scheme="https://neilli.cn/tags/Interceptor/"/>
    
  </entry>
  
</feed>
